{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Claude Code Configuration Examples This is a collection of example claude.md files for Claude Code. The raw markdown files are available at github.com/grokify/claude-code-config . Example claude.md files: Build-Lint Check DevOps Infrastructure Project Enterprise Backend Service Mobile App Development - React Native Open Soruce Liberary Development Python Data Science Project Web Application Development Team Example commands API Test Code Review Document Feature Integrate Parallel Work Parallel Agents Parallel Work","title":"Home"},{"location":"#claude-code-configuration-examples","text":"This is a collection of example claude.md files for Claude Code. The raw markdown files are available at github.com/grokify/claude-code-config . Example claude.md files: Build-Lint Check DevOps Infrastructure Project Enterprise Backend Service Mobile App Development - React Native Open Soruce Liberary Development Python Data Science Project Web Application Development Team Example commands API Test Code Review Document Feature Integrate Parallel Work Parallel Agents Parallel Work","title":"Claude Code Configuration Examples"},{"location":"claude.md/claude_build-lint-check/","text":"Build-Lint Check From: https://www.reddit.com/r/ClaudeAI/comments/1ko5pxk/comment/msohsxt/ Critical Rules - DO NOT VIOLATE NEVER create mock data or simplified components unless explicitly told to do so NEVER replace existing complex components with simplified versions - always fix the actual problem ALWAYS work with the existing codebase - do not create new simplified alternatives ALWAYS find and fix the root cause of issues instead of creating workarounds When debugging issues, focus on fixing the existing implementation, not replacing it When something doesn't work, debug and fix it - don't start over with a simple version ALWAYS check MUI X v8 AND MUI v7 DOCS before making changes to MUI-related components - they have breaking changes TypeScript and Linting ALWAYS add explicit types to all function parameters, variables, and return types ALWAYS run pnpm build or appropriate linter command before considering any code changes complete Fix all linter and TypeScript errors immediately - don't leave them for the user to fix When making changes to multiple files, check each one for type errors Prisma Usage NEVER use raw SQL queries ($queryRaw, $queryRawUnsafe) - always use Prisma Client methods When relations don't exist in the schema, use separate queries with findMany() and create lookup maps Always check the Prisma schema before assuming relations exist MUI Component Guidelines ALWAYS check MUI X v8 AND MUI V7 DOCS before making changes to related components. They are very new versions and likely have breaking changes you do not know about.","title":"Build-Lint Check"},{"location":"claude.md/claude_build-lint-check/#build-lint-check","text":"From: https://www.reddit.com/r/ClaudeAI/comments/1ko5pxk/comment/msohsxt/","title":"Build-Lint Check"},{"location":"claude.md/claude_build-lint-check/#critical-rules-do-not-violate","text":"NEVER create mock data or simplified components unless explicitly told to do so NEVER replace existing complex components with simplified versions - always fix the actual problem ALWAYS work with the existing codebase - do not create new simplified alternatives ALWAYS find and fix the root cause of issues instead of creating workarounds When debugging issues, focus on fixing the existing implementation, not replacing it When something doesn't work, debug and fix it - don't start over with a simple version ALWAYS check MUI X v8 AND MUI v7 DOCS before making changes to MUI-related components - they have breaking changes","title":"Critical Rules - DO NOT VIOLATE"},{"location":"claude.md/claude_build-lint-check/#typescript-and-linting","text":"ALWAYS add explicit types to all function parameters, variables, and return types ALWAYS run pnpm build or appropriate linter command before considering any code changes complete Fix all linter and TypeScript errors immediately - don't leave them for the user to fix When making changes to multiple files, check each one for type errors","title":"TypeScript and Linting"},{"location":"claude.md/claude_build-lint-check/#prisma-usage","text":"NEVER use raw SQL queries ($queryRaw, $queryRawUnsafe) - always use Prisma Client methods When relations don't exist in the schema, use separate queries with findMany() and create lookup maps Always check the Prisma schema before assuming relations exist","title":"Prisma Usage"},{"location":"claude.md/claude_build-lint-check/#mui-component-guidelines","text":"ALWAYS check MUI X v8 AND MUI V7 DOCS before making changes to related components. They are very new versions and likely have breaking changes you do not know about.","title":"MUI Component Guidelines"},{"location":"claude.md/claude_devops-infrastructure-project/","text":"Project: Multi-Cloud Infrastructure Platform Infrastructure as Code Standards Primary Tool : Terraform with HCL Cloud Providers : AWS, Azure, GCP Configuration Management : Ansible playbooks Container Orchestration : Kubernetes with Helm charts Monitoring : Prometheus, Grafana, ELK stack Workflow Requirements Create infrastructure branch: infra-[environment]-[component] Run terraform plan and review changes carefully Test in development environment first Update documentation in /docs/runbooks Peer review required for production changes Use conventional commits with clear impact description Directory Structure /terraform/[provider]/[environment]/ : Environment-specific configurations /ansible/playbooks/ : Configuration management scripts /k8s/[namespace]/ : Kubernetes manifests and Helm charts /scripts/ : Automation and deployment scripts /docs/ : Architecture decisions and runbooks Security and Compliance All secrets must use external secret management (AWS Secrets Manager, etc.) Enable encryption at rest and in transit for all data stores Implement least-privilege access policies Use service accounts, never personal credentials in automation Maintain audit logs for all infrastructure changes Deployment Principles Use blue-green deployments for zero-downtime updates Implement automatic rollback on health check failures Tag all resources with environment, owner, and cost-center Use infrastructure modules for reusability across environments Implement proper backup and disaster recovery procedures Monitoring and Alerting Set up alerts for resource utilization > 80% Monitor certificate expiration dates Track deployment success/failure rates Implement SLA monitoring for critical services Use runbooks for common incident response procedures Cost Optimization Implement auto-scaling policies for dynamic workloads Use spot instances where appropriate for non-critical workloads Regular cost reviews with resource rightsizing Implement resource lifecycle policies for cleanup","title":"DevOps Infrastructure Project"},{"location":"claude.md/claude_devops-infrastructure-project/#project-multi-cloud-infrastructure-platform","text":"","title":"Project: Multi-Cloud Infrastructure Platform"},{"location":"claude.md/claude_devops-infrastructure-project/#infrastructure-as-code-standards","text":"Primary Tool : Terraform with HCL Cloud Providers : AWS, Azure, GCP Configuration Management : Ansible playbooks Container Orchestration : Kubernetes with Helm charts Monitoring : Prometheus, Grafana, ELK stack","title":"Infrastructure as Code Standards"},{"location":"claude.md/claude_devops-infrastructure-project/#workflow-requirements","text":"Create infrastructure branch: infra-[environment]-[component] Run terraform plan and review changes carefully Test in development environment first Update documentation in /docs/runbooks Peer review required for production changes Use conventional commits with clear impact description","title":"Workflow Requirements"},{"location":"claude.md/claude_devops-infrastructure-project/#directory-structure","text":"/terraform/[provider]/[environment]/ : Environment-specific configurations /ansible/playbooks/ : Configuration management scripts /k8s/[namespace]/ : Kubernetes manifests and Helm charts /scripts/ : Automation and deployment scripts /docs/ : Architecture decisions and runbooks","title":"Directory Structure"},{"location":"claude.md/claude_devops-infrastructure-project/#security-and-compliance","text":"All secrets must use external secret management (AWS Secrets Manager, etc.) Enable encryption at rest and in transit for all data stores Implement least-privilege access policies Use service accounts, never personal credentials in automation Maintain audit logs for all infrastructure changes","title":"Security and Compliance"},{"location":"claude.md/claude_devops-infrastructure-project/#deployment-principles","text":"Use blue-green deployments for zero-downtime updates Implement automatic rollback on health check failures Tag all resources with environment, owner, and cost-center Use infrastructure modules for reusability across environments Implement proper backup and disaster recovery procedures","title":"Deployment Principles"},{"location":"claude.md/claude_devops-infrastructure-project/#monitoring-and-alerting","text":"Set up alerts for resource utilization > 80% Monitor certificate expiration dates Track deployment success/failure rates Implement SLA monitoring for critical services Use runbooks for common incident response procedures","title":"Monitoring and Alerting"},{"location":"claude.md/claude_devops-infrastructure-project/#cost-optimization","text":"Implement auto-scaling policies for dynamic workloads Use spot instances where appropriate for non-critical workloads Regular cost reviews with resource rightsizing Implement resource lifecycle policies for cleanup","title":"Cost Optimization"},{"location":"claude.md/claude_enterprise-backend-service/","text":"Project: Payment Processing Microservice Service Architecture Framework : Spring Boot 3.1 with Java 17 Database : PostgreSQL with JPA/Hibernate Security : OAuth 2.0 with JWT tokens Documentation : OpenAPI 3.0 specifications Deployment : Docker containers with Kubernetes Development Workflow Create feature branch: backend-[ticket-number]-[description] Write integration tests for all new endpoints Update OpenAPI documentation for API changes Run full test suite: ./gradlew test integrationTest Ensure Docker build succeeds: docker build -t payment-service . Commit with ticket reference: feat: [TICKET-123] Add payment validation Code Standards Follow Google Java Style Guide Use Spring Boot conventions for package structure All REST endpoints must have comprehensive validation Use DTOs for all external API contracts Implement proper exception handling with @ControllerAdvice Package Structure controller : REST endpoints and request/response handling service : Business logic and transaction management repository : Data access layer with JPA repositories config : Configuration classes and beans dto : Data Transfer Objects for API contracts entity : JPA entities for database mapping exception : Custom exceptions and error handling Security Requirements All endpoints require authentication except health checks Validate all inputs with Bean Validation annotations Use parameterized queries to prevent SQL injection Log security events for audit trail Never expose internal entity models in API responses Quality Gates Minimum 85% test coverage (unit + integration) All dependencies must be up-to-date and vulnerability-free SonarQube quality gate must pass All database migrations must be reversible Performance tests must complete under 200ms for standard operations Monitoring and Logging Use structured logging with JSON format Include correlation IDs for request tracing Monitor key metrics: response time, error rate, throughput Implement health checks for Kubernetes readiness/liveness probes","title":"Enterprise Backend Service"},{"location":"claude.md/claude_enterprise-backend-service/#project-payment-processing-microservice","text":"","title":"Project: Payment Processing Microservice"},{"location":"claude.md/claude_enterprise-backend-service/#service-architecture","text":"Framework : Spring Boot 3.1 with Java 17 Database : PostgreSQL with JPA/Hibernate Security : OAuth 2.0 with JWT tokens Documentation : OpenAPI 3.0 specifications Deployment : Docker containers with Kubernetes","title":"Service Architecture"},{"location":"claude.md/claude_enterprise-backend-service/#development-workflow","text":"Create feature branch: backend-[ticket-number]-[description] Write integration tests for all new endpoints Update OpenAPI documentation for API changes Run full test suite: ./gradlew test integrationTest Ensure Docker build succeeds: docker build -t payment-service . Commit with ticket reference: feat: [TICKET-123] Add payment validation","title":"Development Workflow"},{"location":"claude.md/claude_enterprise-backend-service/#code-standards","text":"Follow Google Java Style Guide Use Spring Boot conventions for package structure All REST endpoints must have comprehensive validation Use DTOs for all external API contracts Implement proper exception handling with @ControllerAdvice","title":"Code Standards"},{"location":"claude.md/claude_enterprise-backend-service/#package-structure","text":"controller : REST endpoints and request/response handling service : Business logic and transaction management repository : Data access layer with JPA repositories config : Configuration classes and beans dto : Data Transfer Objects for API contracts entity : JPA entities for database mapping exception : Custom exceptions and error handling","title":"Package Structure"},{"location":"claude.md/claude_enterprise-backend-service/#security-requirements","text":"All endpoints require authentication except health checks Validate all inputs with Bean Validation annotations Use parameterized queries to prevent SQL injection Log security events for audit trail Never expose internal entity models in API responses","title":"Security Requirements"},{"location":"claude.md/claude_enterprise-backend-service/#quality-gates","text":"Minimum 85% test coverage (unit + integration) All dependencies must be up-to-date and vulnerability-free SonarQube quality gate must pass All database migrations must be reversible Performance tests must complete under 200ms for standard operations","title":"Quality Gates"},{"location":"claude.md/claude_enterprise-backend-service/#monitoring-and-logging","text":"Use structured logging with JSON format Include correlation IDs for request tracing Monitor key metrics: response time, error rate, throughput Implement health checks for Kubernetes readiness/liveness probes","title":"Monitoring and Logging"},{"location":"claude.md/claude_fullstack_go_react/","text":"Claude Code Configuration - Full Stack Development This is a Claude Code configuration file for building full stack applications with React/TypeScript frontend and Go backend using Ent ORM. Project Overview Stack: Astro + React + TypeScript + Shadcn/ui | Go + Ent | Supabase Auth Testing: Jest + React Testing Library | Go testing + Testify Quality: WCAG 2.3 AA | Security Analysis | Performance Optimization | SEO Optimized Core Technologies Frontend Astro 4+ as the meta-framework with SSR/SSG capabilities React 18+ with TypeScript 5+ for interactive components Shadcn/ui component library with Tailwind CSS Astro routing for file-based routing and SEO optimization Supabase JavaScript SDK for auth and real-time features View Transitions API for smooth page transitions Backend Go 1.21+ with idiomatic patterns Gin web framework for HTTP routing Ent (entgo.io) for database schema and queries Standard library following effective Go principles Supabase Go Client for server-side operations Database & Auth Supabase (PostgreSQL) as primary database Ent for schema definition and type-safe queries Supabase Auth for user management Row Level Security (RLS) for data protection Testing & Quality Jest + React Testing Library for frontend testing jest-axe for accessibility testing Go testing package + Testify for backend testing Playwright for end-to-end testing Project Structure project/ \u251c\u2500\u2500 frontend/ \u2502 \u251c\u2500\u2500 src/ \u2502 \u2502 \u251c\u2500\u2500 components/ \u2502 \u2502 \u2502 \u251c\u2500\u2500 ui/ # Shadcn components \u2502 \u2502 \u2502 \u251c\u2500\u2500 react/ # Interactive React components \u2502 \u2502 \u2502 \u2514\u2500\u2500 astro/ # Static Astro components \u2502 \u2502 \u251c\u2500\u2500 hooks/ # Custom React hooks \u2502 \u2502 \u251c\u2500\u2500 lib/ \u2502 \u2502 \u2502 \u251c\u2500\u2500 supabase.ts # Supabase client \u2502 \u2502 \u2502 \u2514\u2500\u2500 utils.ts # Utility functions \u2502 \u2502 \u251c\u2500\u2500 layouts/ # Astro layout components \u2502 \u2502 \u251c\u2500\u2500 pages/ # File-based routing (Astro) \u2502 \u2502 \u251c\u2500\u2500 content/ # Content collections \u2502 \u2502 \u251c\u2500\u2500 types/ # TypeScript type definitions \u2502 \u2502 \u2514\u2500\u2500 __tests__/ # Test files \u2502 \u251c\u2500\u2500 public/ \u2502 \u251c\u2500\u2500 package.json \u2502 \u251c\u2500\u2500 tsconfig.json \u2502 \u251c\u2500\u2500 astro.config.mjs \u2502 \u251c\u2500\u2500 tailwind.config.js \u2502 \u251c\u2500\u2500 components.json # Shadcn config \u2502 \u2514\u2500\u2500 jest.config.js \u251c\u2500\u2500 backend/ \u2502 \u251c\u2500\u2500 cmd/ \u2502 \u2502 \u2514\u2500\u2500 server/ \u2502 \u2502 \u2514\u2500\u2500 main.go \u2502 \u251c\u2500\u2500 internal/ \u2502 \u2502 \u251c\u2500\u2500 auth/ # Authentication middleware \u2502 \u2502 \u251c\u2500\u2500 handlers/ # HTTP handlers \u2502 \u2502 \u251c\u2500\u2500 middleware/ # Custom middleware \u2502 \u2502 \u2514\u2500\u2500 services/ # Business logic \u2502 \u251c\u2500\u2500 ent/ # Ent generated code \u2502 \u2502 \u251c\u2500\u2500 schema/ # Entity schemas \u2502 \u2502 \u251c\u2500\u2500 migrate/ # Migrations \u2502 \u2502 \u2514\u2500\u2500 ... # Generated files \u2502 \u251c\u2500\u2500 pkg/ # Shared packages \u2502 \u251c\u2500\u2500 tests/ # Test files \u2502 \u251c\u2500\u2500 go.mod \u2502 \u251c\u2500\u2500 go.sum \u2502 \u2514\u2500\u2500 ent.go # Ent configuration \u251c\u2500\u2500 docker-compose.yml \u251c\u2500\u2500 .github/workflows/ \u251c\u2500\u2500 Claude.md # This configuration file \u2514\u2500\u2500 README.md Code Generation Capabilities React Components with TypeScript Generate SEO-friendly Astro components with optional React interactivity Implement proper accessibility attributes (ARIA, semantic HTML) Create custom hooks for Supabase integration Build forms with validation and error handling Implement responsive layouts with Tailwind CSS Generate meta tags and structured data for SEO Create content collections for blog posts and dynamic content Go Backend with Ent Generate HTTP handlers following Go conventions Create Ent entity schemas with proper relationships Implement middleware for authentication and logging Build type-safe database queries with Ent Generate API documentation and OpenAPI specs Authentication & Authorization Implement Supabase auth flows (login, register, password reset) Create protected routes and middleware Handle JWT token validation Implement role-based access control (RBAC) Generate social authentication providers Testing Strategy Frontend Testing // Jest configuration for Astro + React Testing Library { \"testEnvironment\": \"jsdom\", \"setupFilesAfterEnv\": [\"<rootDir>/src/setupTests.ts\"], \"moduleNameMapping\": { \"^@/(.*)$\": \"<rootDir>/src/$1\", \"^astro:(.*)$\": \"<rootDir>/src/test-utils/astro-mocks.ts\" }, \"collectCoverageFrom\": [ \"src/**/*.{ts,tsx,astro}\", \"!src/**/*.d.ts\" ], \"transform\": { \"^.+\\\\.astro$\": \"astro/jest-transformer\" } } Test Types: - Unit tests for React components and Astro components - Integration tests for Supabase client and API routes - Accessibility tests with jest-axe - SEO tests for meta tags and structured data - Performance tests for Core Web Vitals - Mock implementations for external dependencies Backend Testing // Go testing with Ent test client func TestHandler(t *testing.T) { client := enttest.Open(t, \"sqlite3\", \"file:ent?mode=memory&cache=shared&_fk=1\") defer client.Close() // Test implementation } Test Types: - Unit tests for handlers and services - Integration tests with test database - Ent schema and migration testing - Middleware testing with test contexts - API endpoint testing with httptest SEO Optimization with Astro Core SEO Features Server-Side Rendering (SSR): Dynamic content rendered on the server Static Site Generation (SSG): Pre-built pages for maximum performance Hybrid Rendering: Mix of SSR and SSG based on route requirements Automatic Sitemap: Generated XML sitemaps for search engines Built-in SEO Components: Meta tags, Open Graph, Twitter Cards Astro Configuration // astro.config.mjs import { defineConfig } from 'astro/config' import react from '@astrojs/react' import tailwind from '@astrojs/tailwind' import sitemap from '@astrojs/sitemap' export default defineConfig({ site: 'https://yourdomain.com', integrations: [ react(), tailwind(), sitemap(), ], output: 'hybrid', // Enable both SSR and SSG adapter: '@astrojs/node', // For deployment prefetch: { prefetchAll: true, defaultStrategy: 'viewport' } }) Content Collections // src/content/config.ts import { defineCollection, z } from 'astro:content' const blogCollection = defineCollection({ type: 'content', schema: z.object({ title: z.string(), description: z.string(), pubDate: z.date(), author: z.string(), tags: z.array(z.string()), image: z.object({ url: z.string(), alt: z.string() }).optional() }) }) export const collections = { 'blog': blogCollection } Database Schema with Ent Entity Definition Example // ent/schema/user.go package schema import ( \"entgo.io/ent\" \"entgo.io/ent/schema/field\" \"entgo.io/ent/schema/edge\" ) type User struct { ent.Schema } func (User) Fields() []ent.Field { return []ent.Field{ field.String(\"id\").Unique(), field.String(\"email\").Unique(), field.String(\"name\"), field.Time(\"created_at\"), field.Time(\"updated_at\"), } } func (User) Edges() []ent.Edge { return []ent.Edge{ edge.To(\"posts\", Post.Type), } } Ent Configuration Code Generation: Automatic struct and query generation Type Safety: Compile-time query validation Migrations: Automatic schema migration generation Hooks: Before/after hooks for data validation Privacy: Built-in privacy layer for access control Accessibility Standards (WCAG 2.3 AA) Requirements Semantic HTML: Proper heading hierarchy, landmarks, lists ARIA Attributes: Labels, roles, states, and properties Keyboard Navigation: Full functionality without mouse Color Contrast: Minimum 4.5:1 for normal text, 3:1 for large text Focus Management: Visible focus indicators and logical order Screen Reader Support: Meaningful alternative text and descriptions Testing Tools // jest-axe setup import { axe, toHaveNoViolations } from 'jest-axe' expect.extend(toHaveNoViolations) test('should not have accessibility violations', async () => { const { container } = render(<Component />) const results = await axe(container) expect(results).toHaveNoViolations() }) Security Analysis Frontend Security XSS Prevention: Content sanitization and CSP headers CSRF Protection: SameSite cookies and token validation Secure Storage: Secure token storage practices Input Validation: Client-side validation with server verification Dependency Scanning: Regular vulnerability assessments Backend Security SQL Injection: Ent's type-safe queries prevent injection Authentication: JWT validation and refresh token rotation Authorization: Role-based access control and permissions Rate Limiting: Request throttling and DDoS protection Input Validation: Server-side validation and sanitization Performance Optimization Frontend Performance Static Generation: Pre-built pages for optimal loading speeds Partial Hydration: Only interactive components are hydrated Image Optimization: Built-in responsive images with lazy loading Code Splitting: Automatic splitting by route and component Prefetching: Intelligent link prefetching for faster navigation View Transitions: Smooth page transitions with minimal JavaScript Core Web Vitals: Optimized for LCP, FID, and CLS metrics Backend Performance Database Optimization: Ent query optimization and indexing Connection Pooling: Efficient database connection management Caching: Redis integration for frequently accessed data Memory Management: Garbage collection tuning Profiling: CPU and memory profiling with pprof Development Commands Setup Commands # Initialize Astro project npm create astro@latest # Setup integrations npx astro add react tailwind sitemap # Setup Ent schema go run entgo.io/ent/cmd/ent init User Post # Install dependencies npm install @supabase/supabase-js @radix-ui/react-* class-variance-authority # Generate Ent code go generate ./ent Development Commands # Start development servers npm run dev # Astro dev server (SSR) go run cmd/server/main.go # Backend API # Build commands npm run build # Production build npm run preview # Preview production build # Run tests npm test # Frontend tests go test ./... # Backend tests Quality Assurance # Accessibility audit npm run test:a11y # SEO audit npm run test:seo # Security scan npm audit && go list -json -m all | nancy sleuth # Performance analysis npm run build:analyze lighthouse --only-categories=performance,seo,accessibility http://localhost:4321 # Core Web Vitals npm run test:vitals go tool pprof -http=:8080 cpu.prof Environment Configuration Development Environment # Supabase SUPABASE_URL=your_supabase_url SUPABASE_ANON_KEY=your_anon_key # Database DATABASE_URL=postgresql://user:pass@localhost:5432/dbname # Backend PORT=8080 JWT_SECRET=your_jwt_secret CORS_ORIGINS=http://localhost:5173 # Ent ENT_DEBUG=true Production Environment # Supabase SUPABASE_URL=your_production_url SUPABASE_SERVICE_KEY=your_service_key # Database DATABASE_URL=your_production_db_url # Backend PORT=8080 JWT_SECRET=your_production_secret CORS_ORIGINS=https://yourdomain.com # SSL SSL_CERT_PATH=/path/to/cert.pem SSL_KEY_PATH=/path/to/key.pem Quality Gates All code must pass these quality checks before deployment: Tests: 100% test suite passing with >80% coverage Accessibility: Zero axe-core violations Security: No high/critical vulnerabilities Performance: Core Web Vitals within thresholds Type Safety: TypeScript strict mode compliance Go Quality: go vet and golangci-lint passing Bundle Size: Frontend bundle under size limits Integration Patterns Astro + Supabase Integration // src/lib/supabase.ts import { createClient } from '@supabase/supabase-js' export const supabase = createClient( import.meta.env.PUBLIC_SUPABASE_URL, import.meta.env.PUBLIC_SUPABASE_ANON_KEY ) // Server-side client for API routes export const supabaseServer = createClient( import.meta.env.SUPABASE_URL, import.meta.env.SUPABASE_SERVICE_KEY ) API Routes with Astro // src/pages/api/auth/login.ts import type { APIRoute } from 'astro' import { supabaseServer } from '../../../lib/supabase' export const POST: APIRoute = async ({ request }) => { const { email, password } = await request.json() const { data, error } = await supabaseServer.auth.signInWithPassword({ email, password }) if (error) { return new Response(JSON.stringify({ error: error.message }), { status: 400, headers: { 'Content-Type': 'application/json' } }) } return new Response(JSON.stringify({ user: data.user }), { status: 200, headers: { 'Content-Type': 'application/json' } }) } API Design Patterns RESTful endpoints following OpenAPI 3.0 specification GraphQL integration with Ent (optional) Real-time subscriptions via Supabase Proper HTTP status codes and error handling API versioning and backward compatibility AI Assistant Behavior When generating code, always: - Provide complete TypeScript type definitions - Include comprehensive error handling - Add proper accessibility attributes - Generate corresponding test files - Follow established architectural patterns - Include detailed code comments and documentation - Suggest performance optimizations - Validate against security best practices - Ensure WCAG 2.3 AA compliance This configuration enables Claude Code to assist with building production-ready full stack applications that are secure, accessible, performant, and maintainable.","title":"Claude Code Configuration - Full Stack Development"},{"location":"claude.md/claude_fullstack_go_react/#claude-code-configuration-full-stack-development","text":"This is a Claude Code configuration file for building full stack applications with React/TypeScript frontend and Go backend using Ent ORM.","title":"Claude Code Configuration - Full Stack Development"},{"location":"claude.md/claude_fullstack_go_react/#project-overview","text":"Stack: Astro + React + TypeScript + Shadcn/ui | Go + Ent | Supabase Auth Testing: Jest + React Testing Library | Go testing + Testify Quality: WCAG 2.3 AA | Security Analysis | Performance Optimization | SEO Optimized","title":"Project Overview"},{"location":"claude.md/claude_fullstack_go_react/#core-technologies","text":"","title":"Core Technologies"},{"location":"claude.md/claude_fullstack_go_react/#frontend","text":"Astro 4+ as the meta-framework with SSR/SSG capabilities React 18+ with TypeScript 5+ for interactive components Shadcn/ui component library with Tailwind CSS Astro routing for file-based routing and SEO optimization Supabase JavaScript SDK for auth and real-time features View Transitions API for smooth page transitions","title":"Frontend"},{"location":"claude.md/claude_fullstack_go_react/#backend","text":"Go 1.21+ with idiomatic patterns Gin web framework for HTTP routing Ent (entgo.io) for database schema and queries Standard library following effective Go principles Supabase Go Client for server-side operations","title":"Backend"},{"location":"claude.md/claude_fullstack_go_react/#database-auth","text":"Supabase (PostgreSQL) as primary database Ent for schema definition and type-safe queries Supabase Auth for user management Row Level Security (RLS) for data protection","title":"Database &amp; Auth"},{"location":"claude.md/claude_fullstack_go_react/#testing-quality","text":"Jest + React Testing Library for frontend testing jest-axe for accessibility testing Go testing package + Testify for backend testing Playwright for end-to-end testing","title":"Testing &amp; Quality"},{"location":"claude.md/claude_fullstack_go_react/#project-structure","text":"project/ \u251c\u2500\u2500 frontend/ \u2502 \u251c\u2500\u2500 src/ \u2502 \u2502 \u251c\u2500\u2500 components/ \u2502 \u2502 \u2502 \u251c\u2500\u2500 ui/ # Shadcn components \u2502 \u2502 \u2502 \u251c\u2500\u2500 react/ # Interactive React components \u2502 \u2502 \u2502 \u2514\u2500\u2500 astro/ # Static Astro components \u2502 \u2502 \u251c\u2500\u2500 hooks/ # Custom React hooks \u2502 \u2502 \u251c\u2500\u2500 lib/ \u2502 \u2502 \u2502 \u251c\u2500\u2500 supabase.ts # Supabase client \u2502 \u2502 \u2502 \u2514\u2500\u2500 utils.ts # Utility functions \u2502 \u2502 \u251c\u2500\u2500 layouts/ # Astro layout components \u2502 \u2502 \u251c\u2500\u2500 pages/ # File-based routing (Astro) \u2502 \u2502 \u251c\u2500\u2500 content/ # Content collections \u2502 \u2502 \u251c\u2500\u2500 types/ # TypeScript type definitions \u2502 \u2502 \u2514\u2500\u2500 __tests__/ # Test files \u2502 \u251c\u2500\u2500 public/ \u2502 \u251c\u2500\u2500 package.json \u2502 \u251c\u2500\u2500 tsconfig.json \u2502 \u251c\u2500\u2500 astro.config.mjs \u2502 \u251c\u2500\u2500 tailwind.config.js \u2502 \u251c\u2500\u2500 components.json # Shadcn config \u2502 \u2514\u2500\u2500 jest.config.js \u251c\u2500\u2500 backend/ \u2502 \u251c\u2500\u2500 cmd/ \u2502 \u2502 \u2514\u2500\u2500 server/ \u2502 \u2502 \u2514\u2500\u2500 main.go \u2502 \u251c\u2500\u2500 internal/ \u2502 \u2502 \u251c\u2500\u2500 auth/ # Authentication middleware \u2502 \u2502 \u251c\u2500\u2500 handlers/ # HTTP handlers \u2502 \u2502 \u251c\u2500\u2500 middleware/ # Custom middleware \u2502 \u2502 \u2514\u2500\u2500 services/ # Business logic \u2502 \u251c\u2500\u2500 ent/ # Ent generated code \u2502 \u2502 \u251c\u2500\u2500 schema/ # Entity schemas \u2502 \u2502 \u251c\u2500\u2500 migrate/ # Migrations \u2502 \u2502 \u2514\u2500\u2500 ... # Generated files \u2502 \u251c\u2500\u2500 pkg/ # Shared packages \u2502 \u251c\u2500\u2500 tests/ # Test files \u2502 \u251c\u2500\u2500 go.mod \u2502 \u251c\u2500\u2500 go.sum \u2502 \u2514\u2500\u2500 ent.go # Ent configuration \u251c\u2500\u2500 docker-compose.yml \u251c\u2500\u2500 .github/workflows/ \u251c\u2500\u2500 Claude.md # This configuration file \u2514\u2500\u2500 README.md","title":"Project Structure"},{"location":"claude.md/claude_fullstack_go_react/#code-generation-capabilities","text":"","title":"Code Generation Capabilities"},{"location":"claude.md/claude_fullstack_go_react/#react-components-with-typescript","text":"Generate SEO-friendly Astro components with optional React interactivity Implement proper accessibility attributes (ARIA, semantic HTML) Create custom hooks for Supabase integration Build forms with validation and error handling Implement responsive layouts with Tailwind CSS Generate meta tags and structured data for SEO Create content collections for blog posts and dynamic content","title":"React Components with TypeScript"},{"location":"claude.md/claude_fullstack_go_react/#go-backend-with-ent","text":"Generate HTTP handlers following Go conventions Create Ent entity schemas with proper relationships Implement middleware for authentication and logging Build type-safe database queries with Ent Generate API documentation and OpenAPI specs","title":"Go Backend with Ent"},{"location":"claude.md/claude_fullstack_go_react/#authentication-authorization","text":"Implement Supabase auth flows (login, register, password reset) Create protected routes and middleware Handle JWT token validation Implement role-based access control (RBAC) Generate social authentication providers","title":"Authentication &amp; Authorization"},{"location":"claude.md/claude_fullstack_go_react/#testing-strategy","text":"","title":"Testing Strategy"},{"location":"claude.md/claude_fullstack_go_react/#frontend-testing","text":"// Jest configuration for Astro + React Testing Library { \"testEnvironment\": \"jsdom\", \"setupFilesAfterEnv\": [\"<rootDir>/src/setupTests.ts\"], \"moduleNameMapping\": { \"^@/(.*)$\": \"<rootDir>/src/$1\", \"^astro:(.*)$\": \"<rootDir>/src/test-utils/astro-mocks.ts\" }, \"collectCoverageFrom\": [ \"src/**/*.{ts,tsx,astro}\", \"!src/**/*.d.ts\" ], \"transform\": { \"^.+\\\\.astro$\": \"astro/jest-transformer\" } } Test Types: - Unit tests for React components and Astro components - Integration tests for Supabase client and API routes - Accessibility tests with jest-axe - SEO tests for meta tags and structured data - Performance tests for Core Web Vitals - Mock implementations for external dependencies","title":"Frontend Testing"},{"location":"claude.md/claude_fullstack_go_react/#backend-testing","text":"// Go testing with Ent test client func TestHandler(t *testing.T) { client := enttest.Open(t, \"sqlite3\", \"file:ent?mode=memory&cache=shared&_fk=1\") defer client.Close() // Test implementation } Test Types: - Unit tests for handlers and services - Integration tests with test database - Ent schema and migration testing - Middleware testing with test contexts - API endpoint testing with httptest","title":"Backend Testing"},{"location":"claude.md/claude_fullstack_go_react/#seo-optimization-with-astro","text":"","title":"SEO Optimization with Astro"},{"location":"claude.md/claude_fullstack_go_react/#core-seo-features","text":"Server-Side Rendering (SSR): Dynamic content rendered on the server Static Site Generation (SSG): Pre-built pages for maximum performance Hybrid Rendering: Mix of SSR and SSG based on route requirements Automatic Sitemap: Generated XML sitemaps for search engines Built-in SEO Components: Meta tags, Open Graph, Twitter Cards","title":"Core SEO Features"},{"location":"claude.md/claude_fullstack_go_react/#astro-configuration","text":"// astro.config.mjs import { defineConfig } from 'astro/config' import react from '@astrojs/react' import tailwind from '@astrojs/tailwind' import sitemap from '@astrojs/sitemap' export default defineConfig({ site: 'https://yourdomain.com', integrations: [ react(), tailwind(), sitemap(), ], output: 'hybrid', // Enable both SSR and SSG adapter: '@astrojs/node', // For deployment prefetch: { prefetchAll: true, defaultStrategy: 'viewport' } })","title":"Astro Configuration"},{"location":"claude.md/claude_fullstack_go_react/#content-collections","text":"// src/content/config.ts import { defineCollection, z } from 'astro:content' const blogCollection = defineCollection({ type: 'content', schema: z.object({ title: z.string(), description: z.string(), pubDate: z.date(), author: z.string(), tags: z.array(z.string()), image: z.object({ url: z.string(), alt: z.string() }).optional() }) }) export const collections = { 'blog': blogCollection }","title":"Content Collections"},{"location":"claude.md/claude_fullstack_go_react/#database-schema-with-ent","text":"","title":"Database Schema with Ent"},{"location":"claude.md/claude_fullstack_go_react/#entity-definition-example","text":"// ent/schema/user.go package schema import ( \"entgo.io/ent\" \"entgo.io/ent/schema/field\" \"entgo.io/ent/schema/edge\" ) type User struct { ent.Schema } func (User) Fields() []ent.Field { return []ent.Field{ field.String(\"id\").Unique(), field.String(\"email\").Unique(), field.String(\"name\"), field.Time(\"created_at\"), field.Time(\"updated_at\"), } } func (User) Edges() []ent.Edge { return []ent.Edge{ edge.To(\"posts\", Post.Type), } }","title":"Entity Definition Example"},{"location":"claude.md/claude_fullstack_go_react/#ent-configuration","text":"Code Generation: Automatic struct and query generation Type Safety: Compile-time query validation Migrations: Automatic schema migration generation Hooks: Before/after hooks for data validation Privacy: Built-in privacy layer for access control","title":"Ent Configuration"},{"location":"claude.md/claude_fullstack_go_react/#accessibility-standards-wcag-23-aa","text":"","title":"Accessibility Standards (WCAG 2.3 AA)"},{"location":"claude.md/claude_fullstack_go_react/#requirements","text":"Semantic HTML: Proper heading hierarchy, landmarks, lists ARIA Attributes: Labels, roles, states, and properties Keyboard Navigation: Full functionality without mouse Color Contrast: Minimum 4.5:1 for normal text, 3:1 for large text Focus Management: Visible focus indicators and logical order Screen Reader Support: Meaningful alternative text and descriptions","title":"Requirements"},{"location":"claude.md/claude_fullstack_go_react/#testing-tools","text":"// jest-axe setup import { axe, toHaveNoViolations } from 'jest-axe' expect.extend(toHaveNoViolations) test('should not have accessibility violations', async () => { const { container } = render(<Component />) const results = await axe(container) expect(results).toHaveNoViolations() })","title":"Testing Tools"},{"location":"claude.md/claude_fullstack_go_react/#security-analysis","text":"","title":"Security Analysis"},{"location":"claude.md/claude_fullstack_go_react/#frontend-security","text":"XSS Prevention: Content sanitization and CSP headers CSRF Protection: SameSite cookies and token validation Secure Storage: Secure token storage practices Input Validation: Client-side validation with server verification Dependency Scanning: Regular vulnerability assessments","title":"Frontend Security"},{"location":"claude.md/claude_fullstack_go_react/#backend-security","text":"SQL Injection: Ent's type-safe queries prevent injection Authentication: JWT validation and refresh token rotation Authorization: Role-based access control and permissions Rate Limiting: Request throttling and DDoS protection Input Validation: Server-side validation and sanitization","title":"Backend Security"},{"location":"claude.md/claude_fullstack_go_react/#performance-optimization","text":"","title":"Performance Optimization"},{"location":"claude.md/claude_fullstack_go_react/#frontend-performance","text":"Static Generation: Pre-built pages for optimal loading speeds Partial Hydration: Only interactive components are hydrated Image Optimization: Built-in responsive images with lazy loading Code Splitting: Automatic splitting by route and component Prefetching: Intelligent link prefetching for faster navigation View Transitions: Smooth page transitions with minimal JavaScript Core Web Vitals: Optimized for LCP, FID, and CLS metrics","title":"Frontend Performance"},{"location":"claude.md/claude_fullstack_go_react/#backend-performance","text":"Database Optimization: Ent query optimization and indexing Connection Pooling: Efficient database connection management Caching: Redis integration for frequently accessed data Memory Management: Garbage collection tuning Profiling: CPU and memory profiling with pprof","title":"Backend Performance"},{"location":"claude.md/claude_fullstack_go_react/#development-commands","text":"","title":"Development Commands"},{"location":"claude.md/claude_fullstack_go_react/#setup-commands","text":"# Initialize Astro project npm create astro@latest # Setup integrations npx astro add react tailwind sitemap # Setup Ent schema go run entgo.io/ent/cmd/ent init User Post # Install dependencies npm install @supabase/supabase-js @radix-ui/react-* class-variance-authority # Generate Ent code go generate ./ent","title":"Setup Commands"},{"location":"claude.md/claude_fullstack_go_react/#development-commands_1","text":"# Start development servers npm run dev # Astro dev server (SSR) go run cmd/server/main.go # Backend API # Build commands npm run build # Production build npm run preview # Preview production build # Run tests npm test # Frontend tests go test ./... # Backend tests","title":"Development Commands"},{"location":"claude.md/claude_fullstack_go_react/#quality-assurance","text":"# Accessibility audit npm run test:a11y # SEO audit npm run test:seo # Security scan npm audit && go list -json -m all | nancy sleuth # Performance analysis npm run build:analyze lighthouse --only-categories=performance,seo,accessibility http://localhost:4321 # Core Web Vitals npm run test:vitals go tool pprof -http=:8080 cpu.prof","title":"Quality Assurance"},{"location":"claude.md/claude_fullstack_go_react/#environment-configuration","text":"","title":"Environment Configuration"},{"location":"claude.md/claude_fullstack_go_react/#development-environment","text":"# Supabase SUPABASE_URL=your_supabase_url SUPABASE_ANON_KEY=your_anon_key # Database DATABASE_URL=postgresql://user:pass@localhost:5432/dbname # Backend PORT=8080 JWT_SECRET=your_jwt_secret CORS_ORIGINS=http://localhost:5173 # Ent ENT_DEBUG=true","title":"Development Environment"},{"location":"claude.md/claude_fullstack_go_react/#production-environment","text":"# Supabase SUPABASE_URL=your_production_url SUPABASE_SERVICE_KEY=your_service_key # Database DATABASE_URL=your_production_db_url # Backend PORT=8080 JWT_SECRET=your_production_secret CORS_ORIGINS=https://yourdomain.com # SSL SSL_CERT_PATH=/path/to/cert.pem SSL_KEY_PATH=/path/to/key.pem","title":"Production Environment"},{"location":"claude.md/claude_fullstack_go_react/#quality-gates","text":"All code must pass these quality checks before deployment: Tests: 100% test suite passing with >80% coverage Accessibility: Zero axe-core violations Security: No high/critical vulnerabilities Performance: Core Web Vitals within thresholds Type Safety: TypeScript strict mode compliance Go Quality: go vet and golangci-lint passing Bundle Size: Frontend bundle under size limits","title":"Quality Gates"},{"location":"claude.md/claude_fullstack_go_react/#integration-patterns","text":"","title":"Integration Patterns"},{"location":"claude.md/claude_fullstack_go_react/#astro-supabase-integration","text":"// src/lib/supabase.ts import { createClient } from '@supabase/supabase-js' export const supabase = createClient( import.meta.env.PUBLIC_SUPABASE_URL, import.meta.env.PUBLIC_SUPABASE_ANON_KEY ) // Server-side client for API routes export const supabaseServer = createClient( import.meta.env.SUPABASE_URL, import.meta.env.SUPABASE_SERVICE_KEY )","title":"Astro + Supabase Integration"},{"location":"claude.md/claude_fullstack_go_react/#api-routes-with-astro","text":"// src/pages/api/auth/login.ts import type { APIRoute } from 'astro' import { supabaseServer } from '../../../lib/supabase' export const POST: APIRoute = async ({ request }) => { const { email, password } = await request.json() const { data, error } = await supabaseServer.auth.signInWithPassword({ email, password }) if (error) { return new Response(JSON.stringify({ error: error.message }), { status: 400, headers: { 'Content-Type': 'application/json' } }) } return new Response(JSON.stringify({ user: data.user }), { status: 200, headers: { 'Content-Type': 'application/json' } }) }","title":"API Routes with Astro"},{"location":"claude.md/claude_fullstack_go_react/#api-design-patterns","text":"RESTful endpoints following OpenAPI 3.0 specification GraphQL integration with Ent (optional) Real-time subscriptions via Supabase Proper HTTP status codes and error handling API versioning and backward compatibility","title":"API Design Patterns"},{"location":"claude.md/claude_fullstack_go_react/#ai-assistant-behavior","text":"When generating code, always: - Provide complete TypeScript type definitions - Include comprehensive error handling - Add proper accessibility attributes - Generate corresponding test files - Follow established architectural patterns - Include detailed code comments and documentation - Suggest performance optimizations - Validate against security best practices - Ensure WCAG 2.3 AA compliance This configuration enables Claude Code to assist with building production-ready full stack applications that are secure, accessible, performant, and maintainable.","title":"AI Assistant Behavior"},{"location":"claude.md/claude_mobile-app-development-react-native/","text":"Project: FitnessTracker Mobile App Platform Requirements Framework : React Native 0.72+ with TypeScript State Management : Redux Toolkit with RTK Query Navigation : React Navigation v6 UI Library : Native Base for consistent design Platform Support : iOS 14+ and Android API 24+ Branch Strategy Create feature branches: mobile-[feature-name] Use conventional commits: feat: , fix: , refactor: , etc. Test on both iOS and Android before committing Run npm run lint and npm run type-check before commits Code Organization Screens : /src/screens/[FeatureName]/[ScreenName]Screen.tsx Components : /src/components/[ComponentName]/index.tsx Navigation : /src/navigation/[NavigatorName]Navigator.tsx Services : /src/services/[serviceName].ts Store : /src/store/slices/[featureName]Slice.ts Mobile-Specific Standards Use React Native's built-in components before third-party libraries Implement proper error boundaries for crash prevention Use AsyncStorage for local data persistence Follow platform-specific design guidelines (iOS Human Interface, Material Design) Optimize images and use vector graphics when possible Testing Requirements Unit tests with Jest and React Native Testing Library E2E tests with Detox for critical user flows Test on physical devices before major releases Performance testing with Flipper profiling Performance Guidelines Use FlatList for large datasets, never ScrollView Implement proper memoization with React.memo and useMemo Lazy load heavy components and screens Monitor bundle size and use code splitting when necessary","title":"Mobile App Development - React Native"},{"location":"claude.md/claude_mobile-app-development-react-native/#project-fitnesstracker-mobile-app","text":"","title":"Project: FitnessTracker Mobile App"},{"location":"claude.md/claude_mobile-app-development-react-native/#platform-requirements","text":"Framework : React Native 0.72+ with TypeScript State Management : Redux Toolkit with RTK Query Navigation : React Navigation v6 UI Library : Native Base for consistent design Platform Support : iOS 14+ and Android API 24+","title":"Platform Requirements"},{"location":"claude.md/claude_mobile-app-development-react-native/#branch-strategy","text":"Create feature branches: mobile-[feature-name] Use conventional commits: feat: , fix: , refactor: , etc. Test on both iOS and Android before committing Run npm run lint and npm run type-check before commits","title":"Branch Strategy"},{"location":"claude.md/claude_mobile-app-development-react-native/#code-organization","text":"Screens : /src/screens/[FeatureName]/[ScreenName]Screen.tsx Components : /src/components/[ComponentName]/index.tsx Navigation : /src/navigation/[NavigatorName]Navigator.tsx Services : /src/services/[serviceName].ts Store : /src/store/slices/[featureName]Slice.ts","title":"Code Organization"},{"location":"claude.md/claude_mobile-app-development-react-native/#mobile-specific-standards","text":"Use React Native's built-in components before third-party libraries Implement proper error boundaries for crash prevention Use AsyncStorage for local data persistence Follow platform-specific design guidelines (iOS Human Interface, Material Design) Optimize images and use vector graphics when possible","title":"Mobile-Specific Standards"},{"location":"claude.md/claude_mobile-app-development-react-native/#testing-requirements","text":"Unit tests with Jest and React Native Testing Library E2E tests with Detox for critical user flows Test on physical devices before major releases Performance testing with Flipper profiling","title":"Testing Requirements"},{"location":"claude.md/claude_mobile-app-development-react-native/#performance-guidelines","text":"Use FlatList for large datasets, never ScrollView Implement proper memoization with React.memo and useMemo Lazy load heavy components and screens Monitor bundle size and use code splitting when necessary","title":"Performance Guidelines"},{"location":"claude.md/claude_open-source-library-development/","text":"Project: DataValidator - Python Data Validation Library Library Design Principles API Design : Simple, intuitive, and Pythonic Dependencies : Minimal external dependencies Compatibility : Python 3.8+ support Performance : Optimize for speed and memory efficiency Documentation : Comprehensive with examples Development Workflow Create feature branch: feature-[functionality] or fix-[issue-number] Write tests first (TDD approach) Ensure 100% test coverage for new code Update documentation and examples Run full test suite across Python versions: tox Update CHANGELOG.md with clear user-facing description Code Quality Standards Follow PEP 8 with line length limit of 88 characters Use type hints for all public APIs Docstrings required for all public functions/classes (Google style) Use dataclasses or Pydantic for structured data Implement proper error handling with custom exceptions Project Structure /src/datavalidator/ : Main library code /tests/ : Comprehensive test suite /docs/ : Sphinx documentation /examples/ : Usage examples and tutorials /benchmarks/ : Performance testing scripts Testing Requirements Unit tests with pytest for all functionality Property-based testing with Hypothesis for edge cases Performance benchmarks for critical paths Integration tests with popular data libraries (pandas, numpy) Test matrix: Python 3.8, 3.9, 3.10, 3.11, 3.12 Documentation Standards README with quick start guide and installation API documentation generated from docstrings Tutorial notebooks for common use cases Performance guidelines and best practices Migration guides for major version changes Release Process Semantic versioning (MAJOR.MINOR.PATCH) Automated testing on multiple Python versions Code coverage reports and quality metrics Security scanning for vulnerabilities Automated PyPI releases via GitHub Actions Community Guidelines Welcome contributions with clear CONTRIBUTING.md Issue templates for bugs and feature requests Code of conduct for inclusive community Regular maintenance and dependency updates Responsive to community feedback and issues","title":"Open Soruce Liberary Development"},{"location":"claude.md/claude_open-source-library-development/#project-datavalidator-python-data-validation-library","text":"","title":"Project: DataValidator - Python Data Validation Library"},{"location":"claude.md/claude_open-source-library-development/#library-design-principles","text":"API Design : Simple, intuitive, and Pythonic Dependencies : Minimal external dependencies Compatibility : Python 3.8+ support Performance : Optimize for speed and memory efficiency Documentation : Comprehensive with examples","title":"Library Design Principles"},{"location":"claude.md/claude_open-source-library-development/#development-workflow","text":"Create feature branch: feature-[functionality] or fix-[issue-number] Write tests first (TDD approach) Ensure 100% test coverage for new code Update documentation and examples Run full test suite across Python versions: tox Update CHANGELOG.md with clear user-facing description","title":"Development Workflow"},{"location":"claude.md/claude_open-source-library-development/#code-quality-standards","text":"Follow PEP 8 with line length limit of 88 characters Use type hints for all public APIs Docstrings required for all public functions/classes (Google style) Use dataclasses or Pydantic for structured data Implement proper error handling with custom exceptions","title":"Code Quality Standards"},{"location":"claude.md/claude_open-source-library-development/#project-structure","text":"/src/datavalidator/ : Main library code /tests/ : Comprehensive test suite /docs/ : Sphinx documentation /examples/ : Usage examples and tutorials /benchmarks/ : Performance testing scripts","title":"Project Structure"},{"location":"claude.md/claude_open-source-library-development/#testing-requirements","text":"Unit tests with pytest for all functionality Property-based testing with Hypothesis for edge cases Performance benchmarks for critical paths Integration tests with popular data libraries (pandas, numpy) Test matrix: Python 3.8, 3.9, 3.10, 3.11, 3.12","title":"Testing Requirements"},{"location":"claude.md/claude_open-source-library-development/#documentation-standards","text":"README with quick start guide and installation API documentation generated from docstrings Tutorial notebooks for common use cases Performance guidelines and best practices Migration guides for major version changes","title":"Documentation Standards"},{"location":"claude.md/claude_open-source-library-development/#release-process","text":"Semantic versioning (MAJOR.MINOR.PATCH) Automated testing on multiple Python versions Code coverage reports and quality metrics Security scanning for vulnerabilities Automated PyPI releases via GitHub Actions","title":"Release Process"},{"location":"claude.md/claude_open-source-library-development/#community-guidelines","text":"Welcome contributions with clear CONTRIBUTING.md Issue templates for bugs and feature requests Code of conduct for inclusive community Regular maintenance and dependency updates Responsive to community feedback and issues","title":"Community Guidelines"},{"location":"claude.md/claude_python-data-science-project/","text":"Project: Customer Analytics Pipeline Development Standards Language : Python 3.11+ Code Style : Follow PEP 8 strictly, use Black for formatting Type Hints : Required for all function signatures and class definitions Documentation : Docstrings required for all public functions and classes Workflow Requirements Create feature branch: analysis-[description] or model-[description] Write unit tests for all data processing functions Run pytest and ensure all tests pass Run black . and flake8 before committing Update relevant documentation in /docs if adding new features Project Structure /src/data : Data ingestion and preprocessing modules /src/models : ML model definitions and training scripts /src/analysis : Exploratory analysis notebooks and scripts /src/utils : Shared utility functions /tests : Comprehensive test suite /configs : Configuration files for different environments Data Handling Standards Use Pandas for data manipulation, prefer vectorized operations All data files must be documented in /data/README.md Use Pydantic models for data validation and serialization Never commit raw data files to version control Use environment variables for database connections and API keys ML/Analysis Guidelines Use scikit-learn for standard ML algorithms Notebook naming: YYYY-MM-DD-[initials]-[description].ipynb Save all trained models with versioning in /models/trained Use MLflow for experiment tracking Include model performance metrics in commit messages Dependencies Core: pandas, numpy, scikit-learn, matplotlib, seaborn ML: xgboost, lightgbm, optuna Data: sqlalchemy, pydantic, requests Testing: pytest, pytest-cov","title":"Python Data Science Project"},{"location":"claude.md/claude_python-data-science-project/#project-customer-analytics-pipeline","text":"","title":"Project: Customer Analytics Pipeline"},{"location":"claude.md/claude_python-data-science-project/#development-standards","text":"Language : Python 3.11+ Code Style : Follow PEP 8 strictly, use Black for formatting Type Hints : Required for all function signatures and class definitions Documentation : Docstrings required for all public functions and classes","title":"Development Standards"},{"location":"claude.md/claude_python-data-science-project/#workflow-requirements","text":"Create feature branch: analysis-[description] or model-[description] Write unit tests for all data processing functions Run pytest and ensure all tests pass Run black . and flake8 before committing Update relevant documentation in /docs if adding new features","title":"Workflow Requirements"},{"location":"claude.md/claude_python-data-science-project/#project-structure","text":"/src/data : Data ingestion and preprocessing modules /src/models : ML model definitions and training scripts /src/analysis : Exploratory analysis notebooks and scripts /src/utils : Shared utility functions /tests : Comprehensive test suite /configs : Configuration files for different environments","title":"Project Structure"},{"location":"claude.md/claude_python-data-science-project/#data-handling-standards","text":"Use Pandas for data manipulation, prefer vectorized operations All data files must be documented in /data/README.md Use Pydantic models for data validation and serialization Never commit raw data files to version control Use environment variables for database connections and API keys","title":"Data Handling Standards"},{"location":"claude.md/claude_python-data-science-project/#mlanalysis-guidelines","text":"Use scikit-learn for standard ML algorithms Notebook naming: YYYY-MM-DD-[initials]-[description].ipynb Save all trained models with versioning in /models/trained Use MLflow for experiment tracking Include model performance metrics in commit messages","title":"ML/Analysis Guidelines"},{"location":"claude.md/claude_python-data-science-project/#dependencies","text":"Core: pandas, numpy, scikit-learn, matplotlib, seaborn ML: xgboost, lightgbm, optuna Data: sqlalchemy, pydantic, requests Testing: pytest, pytest-cov","title":"Dependencies"},{"location":"claude.md/claude_web-application-development-team/","text":"Project: TaskFlow Web Application Core Principles IMPORTANT : Whenever you write code, it MUST follow SOLID design principles. Never write code that violates these principles. If you do, you will be asked to refactor it. Development Workflow Before making any changes, create and checkout a feature branch named feature-[brief-description] Write comprehensive tests for all new functionality Compile code and run all tests before committing Write detailed commit messages explaining the changes and rationale Commit all changes to the feature branch Architecture Overview Frontend : Next.js 14 with TypeScript and Tailwind CSS State Management : Zustand for client state, React Query for server state Backend : Node.js with Express and Prisma ORM Database : PostgreSQL Testing : Jest for unit tests, Playwright for E2E Code Standards Use TypeScript for all new code with strict type checking Follow the existing component structure in /src/components API routes follow RESTful conventions in /src/pages/api Use Prisma schema definitions for all database operations CSS classes should use Tailwind utilities; custom CSS only when necessary Quality Gates All code must compile without warnings Test coverage must remain above 80% All tests must pass before committing ESLint and Prettier must pass without errors File Organization Components: /src/components/[feature]/[ComponentName].tsx Pages: /src/pages/[route].tsx Utilities: /src/lib/[category]/[utility].ts Types: /src/types/[domain].ts","title":"Web Application Development Team"},{"location":"claude.md/claude_web-application-development-team/#project-taskflow-web-application","text":"","title":"Project: TaskFlow Web Application"},{"location":"claude.md/claude_web-application-development-team/#core-principles","text":"IMPORTANT : Whenever you write code, it MUST follow SOLID design principles. Never write code that violates these principles. If you do, you will be asked to refactor it.","title":"Core Principles"},{"location":"claude.md/claude_web-application-development-team/#development-workflow","text":"Before making any changes, create and checkout a feature branch named feature-[brief-description] Write comprehensive tests for all new functionality Compile code and run all tests before committing Write detailed commit messages explaining the changes and rationale Commit all changes to the feature branch","title":"Development Workflow"},{"location":"claude.md/claude_web-application-development-team/#architecture-overview","text":"Frontend : Next.js 14 with TypeScript and Tailwind CSS State Management : Zustand for client state, React Query for server state Backend : Node.js with Express and Prisma ORM Database : PostgreSQL Testing : Jest for unit tests, Playwright for E2E","title":"Architecture Overview"},{"location":"claude.md/claude_web-application-development-team/#code-standards","text":"Use TypeScript for all new code with strict type checking Follow the existing component structure in /src/components API routes follow RESTful conventions in /src/pages/api Use Prisma schema definitions for all database operations CSS classes should use Tailwind utilities; custom CSS only when necessary","title":"Code Standards"},{"location":"claude.md/claude_web-application-development-team/#quality-gates","text":"All code must compile without warnings Test coverage must remain above 80% All tests must pass before committing ESLint and Prettier must pass without errors","title":"Quality Gates"},{"location":"claude.md/claude_web-application-development-team/#file-organization","text":"Components: /src/components/[feature]/[ComponentName].tsx Pages: /src/pages/[route].tsx Utilities: /src/lib/[category]/[utility].ts Types: /src/types/[domain].ts","title":"File Organization"},{"location":"commands/","text":"Claude Code Commands These commands can be added to .claude/commands . Example usage: /integrate-parallel-work budget-tracking notifications user-settings","title":"Claude Code Commands"},{"location":"commands/#claude-code-commands","text":"These commands can be added to .claude/commands . Example usage: /integrate-parallel-work budget-tracking notifications user-settings","title":"Claude Code Commands"},{"location":"commands/api-test/","text":"API Testing Command Create comprehensive API tests for: $ARGUMENTS Testing Strategy Test the following API endpoints and scenarios based on $ARGUMENTS: Happy Path Testing : Valid request formats Expected response structures Proper HTTP status codes Error Handling Testing : Invalid request payloads Authentication failures Authorization edge cases Rate limiting scenarios Edge Cases : Boundary value testing Large payload handling Concurrent request handling Network timeout scenarios Test Structure Template Create tests in /tests/api/{endpoint-name}.test.ts : describe('{Endpoint Name} API', () => { describe('POST /{endpoint}', () => { it('should create {resource} with valid data', async () => { // Test implementation }); it('should return 400 for invalid data', async () => { // Test implementation }); it('should require authentication', async () => { // Test implementation }); }); describe('GET /{endpoint}', () => { // Additional test cases }); });","title":"API Test"},{"location":"commands/api-test/#api-testing-command","text":"Create comprehensive API tests for: $ARGUMENTS","title":"API Testing Command"},{"location":"commands/api-test/#testing-strategy","text":"Test the following API endpoints and scenarios based on $ARGUMENTS: Happy Path Testing : Valid request formats Expected response structures Proper HTTP status codes Error Handling Testing : Invalid request payloads Authentication failures Authorization edge cases Rate limiting scenarios Edge Cases : Boundary value testing Large payload handling Concurrent request handling Network timeout scenarios","title":"Testing Strategy"},{"location":"commands/api-test/#test-structure-template","text":"Create tests in /tests/api/{endpoint-name}.test.ts : describe('{Endpoint Name} API', () => { describe('POST /{endpoint}', () => { it('should create {resource} with valid data', async () => { // Test implementation }); it('should return 400 for invalid data', async () => { // Test implementation }); it('should require authentication', async () => { // Test implementation }); }); describe('GET /{endpoint}', () => { // Additional test cases }); });","title":"Test Structure Template"},{"location":"commands/code-review/","text":"Code Review Command Carefully perform a comprehensive code review of $ARGUMENTS. Review Standards Examples of excellent code that you should match the design/style/conventions of: src/components/UserProfile/UserProfile.tsx (React components) src/utils/dataValidation.ts (utility functions) src/hooks/useUserData.ts (custom hooks) Process First : Read the example files above to understand our design patterns, naming conventions, and code style Second : Analyze $ARGUMENTS against these standards Third : Create detailed critique covering: Code structure and organization Adherence to established patterns Performance considerations Security implications Maintainability concerns Test coverage gaps Output Requirements Save review as ai-code-reviews/{filename}.review.md for each file reviewed Include specific line references for issues Provide concrete suggestions for improvements Rate overall quality: Excellent/Good/Needs Improvement/Poor Estimate refactoring effort: Low/Medium/High Review Checklist Follows project naming conventions Proper error handling implemented No hardcoded values, secrets, or magic numbers Appropriate comments and documentation Follows existing design principles and consistent with exemplars No obvious security vulnerabilities Performance optimizations considered","title":"Code Review"},{"location":"commands/code-review/#code-review-command","text":"Carefully perform a comprehensive code review of $ARGUMENTS.","title":"Code Review Command"},{"location":"commands/code-review/#review-standards","text":"Examples of excellent code that you should match the design/style/conventions of: src/components/UserProfile/UserProfile.tsx (React components) src/utils/dataValidation.ts (utility functions) src/hooks/useUserData.ts (custom hooks)","title":"Review Standards"},{"location":"commands/code-review/#process","text":"First : Read the example files above to understand our design patterns, naming conventions, and code style Second : Analyze $ARGUMENTS against these standards Third : Create detailed critique covering: Code structure and organization Adherence to established patterns Performance considerations Security implications Maintainability concerns Test coverage gaps","title":"Process"},{"location":"commands/code-review/#output-requirements","text":"Save review as ai-code-reviews/{filename}.review.md for each file reviewed Include specific line references for issues Provide concrete suggestions for improvements Rate overall quality: Excellent/Good/Needs Improvement/Poor Estimate refactoring effort: Low/Medium/High","title":"Output Requirements"},{"location":"commands/code-review/#review-checklist","text":"Follows project naming conventions Proper error handling implemented No hardcoded values, secrets, or magic numbers Appropriate comments and documentation Follows existing design principles and consistent with exemplars No obvious security vulnerabilities Performance optimizations considered","title":"Review Checklist"},{"location":"commands/document-feature/","text":"Documentation Generator Command Generate comprehensive documentation for feature: $ARGUMENTS Documentation Strategy Create dual-layer documentation based on $ARGUMENTS analysis: Developer Documentation : Technical specifications and architecture API endpoints and data models Implementation details and code examples Configuration and environment setup Testing strategies and debugging notes User Documentation : Step-by-step user guides Visual walkthrough with screenshot placeholders Common use cases and scenarios Troubleshooting and FAQ sections Quick reference guides Feature Detection : Analyze codebase to determine feature type (frontend/backend/full-stack) Identify related components, services, and dependencies Map feature integration points and data flow Detect existing documentation patterns to follow File Analysis Process Code Discovery : Search for files related to $ARGUMENTS in: /src/components/ (React/Vue components) /src/pages/ (Route handlers/pages) /src/api/ or /routes/ (API endpoints) /src/services/ (Business logic) /src/utils/ (Helper functions) /src/hooks/ (Custom hooks) /src/types/ (TypeScript definitions) Documentation Structure Detection : Scan existing /docs/ structure Identify naming conventions and organization patterns Check for existing cross-references and linking patterns Developer Documentation Template Create in /docs/dev/{feature-name}-implementation.md : # {Feature Name} - Technical Implementation ## Overview Brief technical description of the feature and its purpose. ## Architecture - **Type**: [Frontend/Backend/Full-Stack] - **Primary Components**: List of main files and their roles - **Dependencies**: External libraries and internal modules used - **Data Flow**: How data moves through the system ## API Specifications ### Endpoints - `METHOD /api/endpoint` - Description - **Request**: Request format and parameters - **Response**: Response structure and status codes - **Authentication**: Required permissions/roles ### Data Models ```typescript interface FeatureModel { // Type definitions } Implementation Details Key Components Component Name ( path/to/file.ts ): Purpose and functionality Service Layer ( path/to/service.ts ): Business logic implementation Database Layer ( path/to/model.ts ): Data persistence details Configuration Environment variables and configuration options required. Security Considerations Authentication, authorization, and data validation requirements. Testing Unit Tests : tests/unit/{feature}.test.ts Integration Tests : tests/integration/{feature}.test.ts API Tests : tests/api/{feature}.test.ts Debugging Guide Common issues and debugging strategies for developers. Related Documentation Link to user documentation Related feature documentation ## User Documentation Template Create in `/docs/user/how-to-{feature-name}.md`: ```markdown # How to Use {Feature Name} ## Overview Simple explanation of what this feature does and why users would want to use it. ## Quick Start 1. **Step 1**: Basic action description ![Screenshot placeholder: Initial state] 2. **Step 2**: Next action with visual guide ![Screenshot placeholder: Action in progress] 3. **Step 3**: Final result ![Screenshot placeholder: Completed state] ## Detailed Guide ### Getting Started Prerequisites and initial setup instructions. ### Step-by-Step Instructions #### Task 1: {Primary Use Case} 1. Navigate to [specific location] ![Screenshot placeholder: Navigation step] 2. Click [specific button/element] ![Screenshot placeholder: Button/element highlighted] 3. Fill in the required information: - **Field 1**: What to enter and why - **Field 2**: Expected format or options ![Screenshot placeholder: Form completion] 4. Confirm your action ![Screenshot placeholder: Confirmation dialog] #### Task 2: {Secondary Use Case} [Additional scenarios and use cases] ## Common Scenarios ### Scenario 1: {Common Use Case} When you want to [goal], follow these steps: 1. [Step with visual cue] 2. [Step with expected outcome] ### Scenario 2: {Edge Case Handling} If you encounter [situation], here's how to handle it: 1. [Troubleshooting step] 2. [Alternative approach] ## Troubleshooting ### Problem: {Common Issue} **Symptoms**: What the user sees **Solution**: Step-by-step fix **Prevention**: How to avoid in future ### Problem: {Another Issue} **Symptoms**: Error messages or behavior **Solution**: Resolution steps **When to contact support**: Escalation criteria ## FAQ **Q: {Common Question}** A: Clear, concise answer with links to relevant sections. **Q: {Technical Question}** A: User-friendly explanation avoiding technical jargon. ## Quick Reference - **Keyboard Shortcuts**: List of useful shortcuts - **Important Links**: Quick access to key features - **Related Features**: Links to complementary functionality ## Need Help? - [Developer Documentation](../dev/{feature-name}-implementation.md) (for technical details) - [Support Contact Information] - [Community Forums/Resources] Cross-Reference Generation Automatically create bidirectional links between: - Developer docs \u2194 User docs - Feature docs \u2194 Related feature docs - API docs \u2194 Implementation examples - Troubleshooting guides \u2194 Technical solutions Screenshot Automation Strategy For user documentation: Placeholder Format : ![Screenshot placeholder: {descriptive-action}] Naming Convention : screenshots/{feature-name}/{step-number}-{action-description}.png Auto-capture Instructions : Include comments for future screenshot automation Alternative Text : Provide descriptive alt text for accessibility Documentation Quality Checklist [ ] Both dev and user docs created [ ] Cross-references properly linked [ ] Screenshots placeholders positioned appropriately [ ] Code examples are functional and tested [ ] API documentation matches actual implementation [ ] User instructions tested by non-technical reviewer [ ] Troubleshooting section covers common issues [ ] Related documentation updated with new feature references Output Structure docs/ \u251c\u2500\u2500 dev/ \u2502 \u2514\u2500\u2500 {feature-name}-implementation.md \u251c\u2500\u2500 user/ \u2502 \u2514\u2500\u2500 how-to-{feature-name}.md \u2514\u2500\u2500 screenshots/ \u2514\u2500\u2500 {feature-name}/ \u251c\u2500\u2500 step-1-navigation.png (placeholder) \u251c\u2500\u2500 step-2-action.png (placeholder) \u2514\u2500\u2500 step-3-result.png (placeholder) Feature Type Detection Guide Frontend Only : Components, hooks, UI logic Backend Only : APIs, services, database models Full-Stack : Both frontend and backend components with data flow Adjust documentation depth and technical detail based on detected feature type.","title":"Document Feature"},{"location":"commands/document-feature/#documentation-generator-command","text":"Generate comprehensive documentation for feature: $ARGUMENTS","title":"Documentation Generator Command"},{"location":"commands/document-feature/#documentation-strategy","text":"Create dual-layer documentation based on $ARGUMENTS analysis: Developer Documentation : Technical specifications and architecture API endpoints and data models Implementation details and code examples Configuration and environment setup Testing strategies and debugging notes User Documentation : Step-by-step user guides Visual walkthrough with screenshot placeholders Common use cases and scenarios Troubleshooting and FAQ sections Quick reference guides Feature Detection : Analyze codebase to determine feature type (frontend/backend/full-stack) Identify related components, services, and dependencies Map feature integration points and data flow Detect existing documentation patterns to follow","title":"Documentation Strategy"},{"location":"commands/document-feature/#file-analysis-process","text":"Code Discovery : Search for files related to $ARGUMENTS in: /src/components/ (React/Vue components) /src/pages/ (Route handlers/pages) /src/api/ or /routes/ (API endpoints) /src/services/ (Business logic) /src/utils/ (Helper functions) /src/hooks/ (Custom hooks) /src/types/ (TypeScript definitions) Documentation Structure Detection : Scan existing /docs/ structure Identify naming conventions and organization patterns Check for existing cross-references and linking patterns","title":"File Analysis Process"},{"location":"commands/document-feature/#developer-documentation-template","text":"Create in /docs/dev/{feature-name}-implementation.md : # {Feature Name} - Technical Implementation ## Overview Brief technical description of the feature and its purpose. ## Architecture - **Type**: [Frontend/Backend/Full-Stack] - **Primary Components**: List of main files and their roles - **Dependencies**: External libraries and internal modules used - **Data Flow**: How data moves through the system ## API Specifications ### Endpoints - `METHOD /api/endpoint` - Description - **Request**: Request format and parameters - **Response**: Response structure and status codes - **Authentication**: Required permissions/roles ### Data Models ```typescript interface FeatureModel { // Type definitions }","title":"Developer Documentation Template"},{"location":"commands/document-feature/#implementation-details","text":"","title":"Implementation Details"},{"location":"commands/document-feature/#key-components","text":"Component Name ( path/to/file.ts ): Purpose and functionality Service Layer ( path/to/service.ts ): Business logic implementation Database Layer ( path/to/model.ts ): Data persistence details","title":"Key Components"},{"location":"commands/document-feature/#configuration","text":"Environment variables and configuration options required.","title":"Configuration"},{"location":"commands/document-feature/#security-considerations","text":"Authentication, authorization, and data validation requirements.","title":"Security Considerations"},{"location":"commands/document-feature/#testing","text":"Unit Tests : tests/unit/{feature}.test.ts Integration Tests : tests/integration/{feature}.test.ts API Tests : tests/api/{feature}.test.ts","title":"Testing"},{"location":"commands/document-feature/#debugging-guide","text":"Common issues and debugging strategies for developers.","title":"Debugging Guide"},{"location":"commands/document-feature/#related-documentation","text":"Link to user documentation Related feature documentation ## User Documentation Template Create in `/docs/user/how-to-{feature-name}.md`: ```markdown # How to Use {Feature Name} ## Overview Simple explanation of what this feature does and why users would want to use it. ## Quick Start 1. **Step 1**: Basic action description ![Screenshot placeholder: Initial state] 2. **Step 2**: Next action with visual guide ![Screenshot placeholder: Action in progress] 3. **Step 3**: Final result ![Screenshot placeholder: Completed state] ## Detailed Guide ### Getting Started Prerequisites and initial setup instructions. ### Step-by-Step Instructions #### Task 1: {Primary Use Case} 1. Navigate to [specific location] ![Screenshot placeholder: Navigation step] 2. Click [specific button/element] ![Screenshot placeholder: Button/element highlighted] 3. Fill in the required information: - **Field 1**: What to enter and why - **Field 2**: Expected format or options ![Screenshot placeholder: Form completion] 4. Confirm your action ![Screenshot placeholder: Confirmation dialog] #### Task 2: {Secondary Use Case} [Additional scenarios and use cases] ## Common Scenarios ### Scenario 1: {Common Use Case} When you want to [goal], follow these steps: 1. [Step with visual cue] 2. [Step with expected outcome] ### Scenario 2: {Edge Case Handling} If you encounter [situation], here's how to handle it: 1. [Troubleshooting step] 2. [Alternative approach] ## Troubleshooting ### Problem: {Common Issue} **Symptoms**: What the user sees **Solution**: Step-by-step fix **Prevention**: How to avoid in future ### Problem: {Another Issue} **Symptoms**: Error messages or behavior **Solution**: Resolution steps **When to contact support**: Escalation criteria ## FAQ **Q: {Common Question}** A: Clear, concise answer with links to relevant sections. **Q: {Technical Question}** A: User-friendly explanation avoiding technical jargon. ## Quick Reference - **Keyboard Shortcuts**: List of useful shortcuts - **Important Links**: Quick access to key features - **Related Features**: Links to complementary functionality ## Need Help? - [Developer Documentation](../dev/{feature-name}-implementation.md) (for technical details) - [Support Contact Information] - [Community Forums/Resources]","title":"Related Documentation"},{"location":"commands/document-feature/#cross-reference-generation","text":"Automatically create bidirectional links between: - Developer docs \u2194 User docs - Feature docs \u2194 Related feature docs - API docs \u2194 Implementation examples - Troubleshooting guides \u2194 Technical solutions","title":"Cross-Reference Generation"},{"location":"commands/document-feature/#screenshot-automation-strategy","text":"For user documentation: Placeholder Format : ![Screenshot placeholder: {descriptive-action}] Naming Convention : screenshots/{feature-name}/{step-number}-{action-description}.png Auto-capture Instructions : Include comments for future screenshot automation Alternative Text : Provide descriptive alt text for accessibility","title":"Screenshot Automation Strategy"},{"location":"commands/document-feature/#documentation-quality-checklist","text":"[ ] Both dev and user docs created [ ] Cross-references properly linked [ ] Screenshots placeholders positioned appropriately [ ] Code examples are functional and tested [ ] API documentation matches actual implementation [ ] User instructions tested by non-technical reviewer [ ] Troubleshooting section covers common issues [ ] Related documentation updated with new feature references","title":"Documentation Quality Checklist"},{"location":"commands/document-feature/#output-structure","text":"docs/ \u251c\u2500\u2500 dev/ \u2502 \u2514\u2500\u2500 {feature-name}-implementation.md \u251c\u2500\u2500 user/ \u2502 \u2514\u2500\u2500 how-to-{feature-name}.md \u2514\u2500\u2500 screenshots/ \u2514\u2500\u2500 {feature-name}/ \u251c\u2500\u2500 step-1-navigation.png (placeholder) \u251c\u2500\u2500 step-2-action.png (placeholder) \u2514\u2500\u2500 step-3-result.png (placeholder)","title":"Output Structure"},{"location":"commands/document-feature/#feature-type-detection-guide","text":"Frontend Only : Components, hooks, UI logic Backend Only : APIs, services, database models Full-Stack : Both frontend and backend components with data flow Adjust documentation depth and technical detail based on detected feature type.","title":"Feature Type Detection Guide"},{"location":"commands/integrate-parallel-work/","text":"I have features developed in parallel worktrees that I need to integrate: $ARGUMENTS Please help me integrate these features: Create a new integration branch called \"integration/parallel-features\" For each feature name provided, merge the branch feature/[feature-name] into the integration branch Resolve any merge conflicts that arise Test that all features work together Run all tests to ensure nothing is broken Once integration is successful, merge to main and clean up branches I want to integrate these safely before merging to main.","title":"Integrate Parallel Work"},{"location":"commands/parallel-agents/","text":"Parallel Agents Command I want to develop features in parallel using Git worktrees and subagents: $ARGUMENTS You are in the parent folder of the main repo. You will need to change to the main repo folder to create the worktrees. Please execute this complete workflow: PHASE 1 - SETUP WORKTREES: For each feature mentioned: Create a worktree at ../expense-tracker-[feature-name] with branch feature/[feature-name] Set up the development environment in each worktree (if needed) List all worktrees created PHASE 2 - SPAWN SUBAGENTS: For each feature, run a subagent in parallel with these instructions: You are working in the expense-tracker-[feature-name] worktree directory This is a completely isolated development environment Implement the [feature-name] feature with full functionality Include proper testing and error handling Compile and run tests, but don't attempt to run the application (e.g., don't do \"npm run\" or \"npm run dev &\", etc.) When complete, write a detailed summary in [feature-name].work.txt in the main expense-tracker-ai directory The summary should include: what was implemented, files created/modified, dependencies added, testing approach, and integration notes PHASE 3 - COORDINATION: Monitor all subagents working in parallel Ensure each subagent completes their feature implementation Verify each subagent creates their work summary file PHASE 4 - FINAL SUMMARY: After all subagents complete: Read all the .work.txt files created by subagents Provide a comprehensive summary of what was accomplished List all features implemented and their status Provide next steps for integration Execute this complete parallel development workflow.","title":"Parallel Agents"},{"location":"commands/parallel-agents/#parallel-agents-command","text":"I want to develop features in parallel using Git worktrees and subagents: $ARGUMENTS You are in the parent folder of the main repo. You will need to change to the main repo folder to create the worktrees. Please execute this complete workflow:","title":"Parallel Agents Command"},{"location":"commands/parallel-agents/#phase-1-setup-worktrees","text":"For each feature mentioned: Create a worktree at ../expense-tracker-[feature-name] with branch feature/[feature-name] Set up the development environment in each worktree (if needed) List all worktrees created","title":"PHASE 1 - SETUP WORKTREES:"},{"location":"commands/parallel-agents/#phase-2-spawn-subagents","text":"For each feature, run a subagent in parallel with these instructions: You are working in the expense-tracker-[feature-name] worktree directory This is a completely isolated development environment Implement the [feature-name] feature with full functionality Include proper testing and error handling Compile and run tests, but don't attempt to run the application (e.g., don't do \"npm run\" or \"npm run dev &\", etc.) When complete, write a detailed summary in [feature-name].work.txt in the main expense-tracker-ai directory The summary should include: what was implemented, files created/modified, dependencies added, testing approach, and integration notes","title":"PHASE 2 - SPAWN SUBAGENTS:"},{"location":"commands/parallel-agents/#phase-3-coordination","text":"Monitor all subagents working in parallel Ensure each subagent completes their feature implementation Verify each subagent creates their work summary file","title":"PHASE 3 - COORDINATION:"},{"location":"commands/parallel-agents/#phase-4-final-summary","text":"After all subagents complete: Read all the .work.txt files created by subagents Provide a comprehensive summary of what was accomplished List all features implemented and their status Provide next steps for integration Execute this complete parallel development workflow.","title":"PHASE 4 - FINAL SUMMARY:"},{"location":"commands/parallel-work/","text":"I want to develop features in parallel for my expense tracker app using Git worktrees: $ARGUMENTS Think about how to divide the work up into separate features unless this has been clearly explained already. Please help me set up the worktree environment: For each feature mentioned, create a worktree at ../expense-tracker-[feature-name] with branch feature/[feature-name] Set up the development environment in each worktree List all worktrees to confirm they were created Explain what each worktree will contain and how they're isolated I want to be able to work on all features simultaneously without conflicts.","title":"Parallel Work"}]}