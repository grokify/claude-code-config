{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Claude.md Examples This is a collection of example claude.md files for Claude Code. The raw markdown files are available at `github.com/grokify/claude-md Build-Lint Check DevOps Infrastructure Project Enterprise Backend Service Mobile App Development - React Native Open Soruce Liberary Development Python Data Science Project Web Application Development Team","title":"Home"},{"location":"#claudemd-examples","text":"This is a collection of example claude.md files for Claude Code. The raw markdown files are available at `github.com/grokify/claude-md Build-Lint Check DevOps Infrastructure Project Enterprise Backend Service Mobile App Development - React Native Open Soruce Liberary Development Python Data Science Project Web Application Development Team","title":"Claude.md Examples"},{"location":"claude.md/claude_build-lint-check/","text":"Build-Lint Check From: https://www.reddit.com/r/ClaudeAI/comments/1ko5pxk/comment/msohsxt/ Critical Rules - DO NOT VIOLATE NEVER create mock data or simplified components unless explicitly told to do so NEVER replace existing complex components with simplified versions - always fix the actual problem ALWAYS work with the existing codebase - do not create new simplified alternatives ALWAYS find and fix the root cause of issues instead of creating workarounds When debugging issues, focus on fixing the existing implementation, not replacing it When something doesn't work, debug and fix it - don't start over with a simple version ALWAYS check MUI X v8 AND MUI v7 DOCS before making changes to MUI-related components - they have breaking changes TypeScript and Linting ALWAYS add explicit types to all function parameters, variables, and return types ALWAYS run pnpm build or appropriate linter command before considering any code changes complete Fix all linter and TypeScript errors immediately - don't leave them for the user to fix When making changes to multiple files, check each one for type errors Prisma Usage NEVER use raw SQL queries ($queryRaw, $queryRawUnsafe) - always use Prisma Client methods When relations don't exist in the schema, use separate queries with findMany() and create lookup maps Always check the Prisma schema before assuming relations exist MUI Component Guidelines ALWAYS check MUI X v8 AND MUI V7 DOCS before making changes to related components. They are very new versions and likely have breaking changes you do not know about.","title":"Build-Lint Check"},{"location":"claude.md/claude_build-lint-check/#build-lint-check","text":"From: https://www.reddit.com/r/ClaudeAI/comments/1ko5pxk/comment/msohsxt/","title":"Build-Lint Check"},{"location":"claude.md/claude_build-lint-check/#critical-rules-do-not-violate","text":"NEVER create mock data or simplified components unless explicitly told to do so NEVER replace existing complex components with simplified versions - always fix the actual problem ALWAYS work with the existing codebase - do not create new simplified alternatives ALWAYS find and fix the root cause of issues instead of creating workarounds When debugging issues, focus on fixing the existing implementation, not replacing it When something doesn't work, debug and fix it - don't start over with a simple version ALWAYS check MUI X v8 AND MUI v7 DOCS before making changes to MUI-related components - they have breaking changes","title":"Critical Rules - DO NOT VIOLATE"},{"location":"claude.md/claude_build-lint-check/#typescript-and-linting","text":"ALWAYS add explicit types to all function parameters, variables, and return types ALWAYS run pnpm build or appropriate linter command before considering any code changes complete Fix all linter and TypeScript errors immediately - don't leave them for the user to fix When making changes to multiple files, check each one for type errors","title":"TypeScript and Linting"},{"location":"claude.md/claude_build-lint-check/#prisma-usage","text":"NEVER use raw SQL queries ($queryRaw, $queryRawUnsafe) - always use Prisma Client methods When relations don't exist in the schema, use separate queries with findMany() and create lookup maps Always check the Prisma schema before assuming relations exist","title":"Prisma Usage"},{"location":"claude.md/claude_build-lint-check/#mui-component-guidelines","text":"ALWAYS check MUI X v8 AND MUI V7 DOCS before making changes to related components. They are very new versions and likely have breaking changes you do not know about.","title":"MUI Component Guidelines"},{"location":"claude.md/claude_devops-infrastructure-project/","text":"Project: Multi-Cloud Infrastructure Platform Infrastructure as Code Standards Primary Tool : Terraform with HCL Cloud Providers : AWS, Azure, GCP Configuration Management : Ansible playbooks Container Orchestration : Kubernetes with Helm charts Monitoring : Prometheus, Grafana, ELK stack Workflow Requirements Create infrastructure branch: infra-[environment]-[component] Run terraform plan and review changes carefully Test in development environment first Update documentation in /docs/runbooks Peer review required for production changes Use conventional commits with clear impact description Directory Structure /terraform/[provider]/[environment]/ : Environment-specific configurations /ansible/playbooks/ : Configuration management scripts /k8s/[namespace]/ : Kubernetes manifests and Helm charts /scripts/ : Automation and deployment scripts /docs/ : Architecture decisions and runbooks Security and Compliance All secrets must use external secret management (AWS Secrets Manager, etc.) Enable encryption at rest and in transit for all data stores Implement least-privilege access policies Use service accounts, never personal credentials in automation Maintain audit logs for all infrastructure changes Deployment Principles Use blue-green deployments for zero-downtime updates Implement automatic rollback on health check failures Tag all resources with environment, owner, and cost-center Use infrastructure modules for reusability across environments Implement proper backup and disaster recovery procedures Monitoring and Alerting Set up alerts for resource utilization > 80% Monitor certificate expiration dates Track deployment success/failure rates Implement SLA monitoring for critical services Use runbooks for common incident response procedures Cost Optimization Implement auto-scaling policies for dynamic workloads Use spot instances where appropriate for non-critical workloads Regular cost reviews with resource rightsizing Implement resource lifecycle policies for cleanup","title":"DevOps Infrastructure Project"},{"location":"claude.md/claude_devops-infrastructure-project/#project-multi-cloud-infrastructure-platform","text":"","title":"Project: Multi-Cloud Infrastructure Platform"},{"location":"claude.md/claude_devops-infrastructure-project/#infrastructure-as-code-standards","text":"Primary Tool : Terraform with HCL Cloud Providers : AWS, Azure, GCP Configuration Management : Ansible playbooks Container Orchestration : Kubernetes with Helm charts Monitoring : Prometheus, Grafana, ELK stack","title":"Infrastructure as Code Standards"},{"location":"claude.md/claude_devops-infrastructure-project/#workflow-requirements","text":"Create infrastructure branch: infra-[environment]-[component] Run terraform plan and review changes carefully Test in development environment first Update documentation in /docs/runbooks Peer review required for production changes Use conventional commits with clear impact description","title":"Workflow Requirements"},{"location":"claude.md/claude_devops-infrastructure-project/#directory-structure","text":"/terraform/[provider]/[environment]/ : Environment-specific configurations /ansible/playbooks/ : Configuration management scripts /k8s/[namespace]/ : Kubernetes manifests and Helm charts /scripts/ : Automation and deployment scripts /docs/ : Architecture decisions and runbooks","title":"Directory Structure"},{"location":"claude.md/claude_devops-infrastructure-project/#security-and-compliance","text":"All secrets must use external secret management (AWS Secrets Manager, etc.) Enable encryption at rest and in transit for all data stores Implement least-privilege access policies Use service accounts, never personal credentials in automation Maintain audit logs for all infrastructure changes","title":"Security and Compliance"},{"location":"claude.md/claude_devops-infrastructure-project/#deployment-principles","text":"Use blue-green deployments for zero-downtime updates Implement automatic rollback on health check failures Tag all resources with environment, owner, and cost-center Use infrastructure modules for reusability across environments Implement proper backup and disaster recovery procedures","title":"Deployment Principles"},{"location":"claude.md/claude_devops-infrastructure-project/#monitoring-and-alerting","text":"Set up alerts for resource utilization > 80% Monitor certificate expiration dates Track deployment success/failure rates Implement SLA monitoring for critical services Use runbooks for common incident response procedures","title":"Monitoring and Alerting"},{"location":"claude.md/claude_devops-infrastructure-project/#cost-optimization","text":"Implement auto-scaling policies for dynamic workloads Use spot instances where appropriate for non-critical workloads Regular cost reviews with resource rightsizing Implement resource lifecycle policies for cleanup","title":"Cost Optimization"},{"location":"claude.md/claude_enterprise-backend-service/","text":"Project: Payment Processing Microservice Service Architecture Framework : Spring Boot 3.1 with Java 17 Database : PostgreSQL with JPA/Hibernate Security : OAuth 2.0 with JWT tokens Documentation : OpenAPI 3.0 specifications Deployment : Docker containers with Kubernetes Development Workflow Create feature branch: backend-[ticket-number]-[description] Write integration tests for all new endpoints Update OpenAPI documentation for API changes Run full test suite: ./gradlew test integrationTest Ensure Docker build succeeds: docker build -t payment-service . Commit with ticket reference: feat: [TICKET-123] Add payment validation Code Standards Follow Google Java Style Guide Use Spring Boot conventions for package structure All REST endpoints must have comprehensive validation Use DTOs for all external API contracts Implement proper exception handling with @ControllerAdvice Package Structure controller : REST endpoints and request/response handling service : Business logic and transaction management repository : Data access layer with JPA repositories config : Configuration classes and beans dto : Data Transfer Objects for API contracts entity : JPA entities for database mapping exception : Custom exceptions and error handling Security Requirements All endpoints require authentication except health checks Validate all inputs with Bean Validation annotations Use parameterized queries to prevent SQL injection Log security events for audit trail Never expose internal entity models in API responses Quality Gates Minimum 85% test coverage (unit + integration) All dependencies must be up-to-date and vulnerability-free SonarQube quality gate must pass All database migrations must be reversible Performance tests must complete under 200ms for standard operations Monitoring and Logging Use structured logging with JSON format Include correlation IDs for request tracing Monitor key metrics: response time, error rate, throughput Implement health checks for Kubernetes readiness/liveness probes","title":"Enterprise Backend Service"},{"location":"claude.md/claude_enterprise-backend-service/#project-payment-processing-microservice","text":"","title":"Project: Payment Processing Microservice"},{"location":"claude.md/claude_enterprise-backend-service/#service-architecture","text":"Framework : Spring Boot 3.1 with Java 17 Database : PostgreSQL with JPA/Hibernate Security : OAuth 2.0 with JWT tokens Documentation : OpenAPI 3.0 specifications Deployment : Docker containers with Kubernetes","title":"Service Architecture"},{"location":"claude.md/claude_enterprise-backend-service/#development-workflow","text":"Create feature branch: backend-[ticket-number]-[description] Write integration tests for all new endpoints Update OpenAPI documentation for API changes Run full test suite: ./gradlew test integrationTest Ensure Docker build succeeds: docker build -t payment-service . Commit with ticket reference: feat: [TICKET-123] Add payment validation","title":"Development Workflow"},{"location":"claude.md/claude_enterprise-backend-service/#code-standards","text":"Follow Google Java Style Guide Use Spring Boot conventions for package structure All REST endpoints must have comprehensive validation Use DTOs for all external API contracts Implement proper exception handling with @ControllerAdvice","title":"Code Standards"},{"location":"claude.md/claude_enterprise-backend-service/#package-structure","text":"controller : REST endpoints and request/response handling service : Business logic and transaction management repository : Data access layer with JPA repositories config : Configuration classes and beans dto : Data Transfer Objects for API contracts entity : JPA entities for database mapping exception : Custom exceptions and error handling","title":"Package Structure"},{"location":"claude.md/claude_enterprise-backend-service/#security-requirements","text":"All endpoints require authentication except health checks Validate all inputs with Bean Validation annotations Use parameterized queries to prevent SQL injection Log security events for audit trail Never expose internal entity models in API responses","title":"Security Requirements"},{"location":"claude.md/claude_enterprise-backend-service/#quality-gates","text":"Minimum 85% test coverage (unit + integration) All dependencies must be up-to-date and vulnerability-free SonarQube quality gate must pass All database migrations must be reversible Performance tests must complete under 200ms for standard operations","title":"Quality Gates"},{"location":"claude.md/claude_enterprise-backend-service/#monitoring-and-logging","text":"Use structured logging with JSON format Include correlation IDs for request tracing Monitor key metrics: response time, error rate, throughput Implement health checks for Kubernetes readiness/liveness probes","title":"Monitoring and Logging"},{"location":"claude.md/claude_mobile-app-development-react-native/","text":"Project: FitnessTracker Mobile App Platform Requirements Framework : React Native 0.72+ with TypeScript State Management : Redux Toolkit with RTK Query Navigation : React Navigation v6 UI Library : Native Base for consistent design Platform Support : iOS 14+ and Android API 24+ Branch Strategy Create feature branches: mobile-[feature-name] Use conventional commits: feat: , fix: , refactor: , etc. Test on both iOS and Android before committing Run npm run lint and npm run type-check before commits Code Organization Screens : /src/screens/[FeatureName]/[ScreenName]Screen.tsx Components : /src/components/[ComponentName]/index.tsx Navigation : /src/navigation/[NavigatorName]Navigator.tsx Services : /src/services/[serviceName].ts Store : /src/store/slices/[featureName]Slice.ts Mobile-Specific Standards Use React Native's built-in components before third-party libraries Implement proper error boundaries for crash prevention Use AsyncStorage for local data persistence Follow platform-specific design guidelines (iOS Human Interface, Material Design) Optimize images and use vector graphics when possible Testing Requirements Unit tests with Jest and React Native Testing Library E2E tests with Detox for critical user flows Test on physical devices before major releases Performance testing with Flipper profiling Performance Guidelines Use FlatList for large datasets, never ScrollView Implement proper memoization with React.memo and useMemo Lazy load heavy components and screens Monitor bundle size and use code splitting when necessary","title":"Mobile App Development - React Native"},{"location":"claude.md/claude_mobile-app-development-react-native/#project-fitnesstracker-mobile-app","text":"","title":"Project: FitnessTracker Mobile App"},{"location":"claude.md/claude_mobile-app-development-react-native/#platform-requirements","text":"Framework : React Native 0.72+ with TypeScript State Management : Redux Toolkit with RTK Query Navigation : React Navigation v6 UI Library : Native Base for consistent design Platform Support : iOS 14+ and Android API 24+","title":"Platform Requirements"},{"location":"claude.md/claude_mobile-app-development-react-native/#branch-strategy","text":"Create feature branches: mobile-[feature-name] Use conventional commits: feat: , fix: , refactor: , etc. Test on both iOS and Android before committing Run npm run lint and npm run type-check before commits","title":"Branch Strategy"},{"location":"claude.md/claude_mobile-app-development-react-native/#code-organization","text":"Screens : /src/screens/[FeatureName]/[ScreenName]Screen.tsx Components : /src/components/[ComponentName]/index.tsx Navigation : /src/navigation/[NavigatorName]Navigator.tsx Services : /src/services/[serviceName].ts Store : /src/store/slices/[featureName]Slice.ts","title":"Code Organization"},{"location":"claude.md/claude_mobile-app-development-react-native/#mobile-specific-standards","text":"Use React Native's built-in components before third-party libraries Implement proper error boundaries for crash prevention Use AsyncStorage for local data persistence Follow platform-specific design guidelines (iOS Human Interface, Material Design) Optimize images and use vector graphics when possible","title":"Mobile-Specific Standards"},{"location":"claude.md/claude_mobile-app-development-react-native/#testing-requirements","text":"Unit tests with Jest and React Native Testing Library E2E tests with Detox for critical user flows Test on physical devices before major releases Performance testing with Flipper profiling","title":"Testing Requirements"},{"location":"claude.md/claude_mobile-app-development-react-native/#performance-guidelines","text":"Use FlatList for large datasets, never ScrollView Implement proper memoization with React.memo and useMemo Lazy load heavy components and screens Monitor bundle size and use code splitting when necessary","title":"Performance Guidelines"},{"location":"claude.md/claude_open-source-library-development/","text":"Project: DataValidator - Python Data Validation Library Library Design Principles API Design : Simple, intuitive, and Pythonic Dependencies : Minimal external dependencies Compatibility : Python 3.8+ support Performance : Optimize for speed and memory efficiency Documentation : Comprehensive with examples Development Workflow Create feature branch: feature-[functionality] or fix-[issue-number] Write tests first (TDD approach) Ensure 100% test coverage for new code Update documentation and examples Run full test suite across Python versions: tox Update CHANGELOG.md with clear user-facing description Code Quality Standards Follow PEP 8 with line length limit of 88 characters Use type hints for all public APIs Docstrings required for all public functions/classes (Google style) Use dataclasses or Pydantic for structured data Implement proper error handling with custom exceptions Project Structure /src/datavalidator/ : Main library code /tests/ : Comprehensive test suite /docs/ : Sphinx documentation /examples/ : Usage examples and tutorials /benchmarks/ : Performance testing scripts Testing Requirements Unit tests with pytest for all functionality Property-based testing with Hypothesis for edge cases Performance benchmarks for critical paths Integration tests with popular data libraries (pandas, numpy) Test matrix: Python 3.8, 3.9, 3.10, 3.11, 3.12 Documentation Standards README with quick start guide and installation API documentation generated from docstrings Tutorial notebooks for common use cases Performance guidelines and best practices Migration guides for major version changes Release Process Semantic versioning (MAJOR.MINOR.PATCH) Automated testing on multiple Python versions Code coverage reports and quality metrics Security scanning for vulnerabilities Automated PyPI releases via GitHub Actions Community Guidelines Welcome contributions with clear CONTRIBUTING.md Issue templates for bugs and feature requests Code of conduct for inclusive community Regular maintenance and dependency updates Responsive to community feedback and issues","title":"Open Soruce Liberary Development"},{"location":"claude.md/claude_open-source-library-development/#project-datavalidator-python-data-validation-library","text":"","title":"Project: DataValidator - Python Data Validation Library"},{"location":"claude.md/claude_open-source-library-development/#library-design-principles","text":"API Design : Simple, intuitive, and Pythonic Dependencies : Minimal external dependencies Compatibility : Python 3.8+ support Performance : Optimize for speed and memory efficiency Documentation : Comprehensive with examples","title":"Library Design Principles"},{"location":"claude.md/claude_open-source-library-development/#development-workflow","text":"Create feature branch: feature-[functionality] or fix-[issue-number] Write tests first (TDD approach) Ensure 100% test coverage for new code Update documentation and examples Run full test suite across Python versions: tox Update CHANGELOG.md with clear user-facing description","title":"Development Workflow"},{"location":"claude.md/claude_open-source-library-development/#code-quality-standards","text":"Follow PEP 8 with line length limit of 88 characters Use type hints for all public APIs Docstrings required for all public functions/classes (Google style) Use dataclasses or Pydantic for structured data Implement proper error handling with custom exceptions","title":"Code Quality Standards"},{"location":"claude.md/claude_open-source-library-development/#project-structure","text":"/src/datavalidator/ : Main library code /tests/ : Comprehensive test suite /docs/ : Sphinx documentation /examples/ : Usage examples and tutorials /benchmarks/ : Performance testing scripts","title":"Project Structure"},{"location":"claude.md/claude_open-source-library-development/#testing-requirements","text":"Unit tests with pytest for all functionality Property-based testing with Hypothesis for edge cases Performance benchmarks for critical paths Integration tests with popular data libraries (pandas, numpy) Test matrix: Python 3.8, 3.9, 3.10, 3.11, 3.12","title":"Testing Requirements"},{"location":"claude.md/claude_open-source-library-development/#documentation-standards","text":"README with quick start guide and installation API documentation generated from docstrings Tutorial notebooks for common use cases Performance guidelines and best practices Migration guides for major version changes","title":"Documentation Standards"},{"location":"claude.md/claude_open-source-library-development/#release-process","text":"Semantic versioning (MAJOR.MINOR.PATCH) Automated testing on multiple Python versions Code coverage reports and quality metrics Security scanning for vulnerabilities Automated PyPI releases via GitHub Actions","title":"Release Process"},{"location":"claude.md/claude_open-source-library-development/#community-guidelines","text":"Welcome contributions with clear CONTRIBUTING.md Issue templates for bugs and feature requests Code of conduct for inclusive community Regular maintenance and dependency updates Responsive to community feedback and issues","title":"Community Guidelines"},{"location":"claude.md/claude_python-data-science-project/","text":"Project: Customer Analytics Pipeline Development Standards Language : Python 3.11+ Code Style : Follow PEP 8 strictly, use Black for formatting Type Hints : Required for all function signatures and class definitions Documentation : Docstrings required for all public functions and classes Workflow Requirements Create feature branch: analysis-[description] or model-[description] Write unit tests for all data processing functions Run pytest and ensure all tests pass Run black . and flake8 before committing Update relevant documentation in /docs if adding new features Project Structure /src/data : Data ingestion and preprocessing modules /src/models : ML model definitions and training scripts /src/analysis : Exploratory analysis notebooks and scripts /src/utils : Shared utility functions /tests : Comprehensive test suite /configs : Configuration files for different environments Data Handling Standards Use Pandas for data manipulation, prefer vectorized operations All data files must be documented in /data/README.md Use Pydantic models for data validation and serialization Never commit raw data files to version control Use environment variables for database connections and API keys ML/Analysis Guidelines Use scikit-learn for standard ML algorithms Notebook naming: YYYY-MM-DD-[initials]-[description].ipynb Save all trained models with versioning in /models/trained Use MLflow for experiment tracking Include model performance metrics in commit messages Dependencies Core: pandas, numpy, scikit-learn, matplotlib, seaborn ML: xgboost, lightgbm, optuna Data: sqlalchemy, pydantic, requests Testing: pytest, pytest-cov","title":"Python Data Science Project"},{"location":"claude.md/claude_python-data-science-project/#project-customer-analytics-pipeline","text":"","title":"Project: Customer Analytics Pipeline"},{"location":"claude.md/claude_python-data-science-project/#development-standards","text":"Language : Python 3.11+ Code Style : Follow PEP 8 strictly, use Black for formatting Type Hints : Required for all function signatures and class definitions Documentation : Docstrings required for all public functions and classes","title":"Development Standards"},{"location":"claude.md/claude_python-data-science-project/#workflow-requirements","text":"Create feature branch: analysis-[description] or model-[description] Write unit tests for all data processing functions Run pytest and ensure all tests pass Run black . and flake8 before committing Update relevant documentation in /docs if adding new features","title":"Workflow Requirements"},{"location":"claude.md/claude_python-data-science-project/#project-structure","text":"/src/data : Data ingestion and preprocessing modules /src/models : ML model definitions and training scripts /src/analysis : Exploratory analysis notebooks and scripts /src/utils : Shared utility functions /tests : Comprehensive test suite /configs : Configuration files for different environments","title":"Project Structure"},{"location":"claude.md/claude_python-data-science-project/#data-handling-standards","text":"Use Pandas for data manipulation, prefer vectorized operations All data files must be documented in /data/README.md Use Pydantic models for data validation and serialization Never commit raw data files to version control Use environment variables for database connections and API keys","title":"Data Handling Standards"},{"location":"claude.md/claude_python-data-science-project/#mlanalysis-guidelines","text":"Use scikit-learn for standard ML algorithms Notebook naming: YYYY-MM-DD-[initials]-[description].ipynb Save all trained models with versioning in /models/trained Use MLflow for experiment tracking Include model performance metrics in commit messages","title":"ML/Analysis Guidelines"},{"location":"claude.md/claude_python-data-science-project/#dependencies","text":"Core: pandas, numpy, scikit-learn, matplotlib, seaborn ML: xgboost, lightgbm, optuna Data: sqlalchemy, pydantic, requests Testing: pytest, pytest-cov","title":"Dependencies"},{"location":"claude.md/claude_web-application-development-team/","text":"Project: TaskFlow Web Application Core Principles IMPORTANT : Whenever you write code, it MUST follow SOLID design principles. Never write code that violates these principles. If you do, you will be asked to refactor it. Development Workflow Before making any changes, create and checkout a feature branch named feature-[brief-description] Write comprehensive tests for all new functionality Compile code and run all tests before committing Write detailed commit messages explaining the changes and rationale Commit all changes to the feature branch Architecture Overview Frontend : Next.js 14 with TypeScript and Tailwind CSS State Management : Zustand for client state, React Query for server state Backend : Node.js with Express and Prisma ORM Database : PostgreSQL Testing : Jest for unit tests, Playwright for E2E Code Standards Use TypeScript for all new code with strict type checking Follow the existing component structure in /src/components API routes follow RESTful conventions in /src/pages/api Use Prisma schema definitions for all database operations CSS classes should use Tailwind utilities; custom CSS only when necessary Quality Gates All code must compile without warnings Test coverage must remain above 80% All tests must pass before committing ESLint and Prettier must pass without errors File Organization Components: /src/components/[feature]/[ComponentName].tsx Pages: /src/pages/[route].tsx Utilities: /src/lib/[category]/[utility].ts Types: /src/types/[domain].ts","title":"Web Application Development Team"},{"location":"claude.md/claude_web-application-development-team/#project-taskflow-web-application","text":"","title":"Project: TaskFlow Web Application"},{"location":"claude.md/claude_web-application-development-team/#core-principles","text":"IMPORTANT : Whenever you write code, it MUST follow SOLID design principles. Never write code that violates these principles. If you do, you will be asked to refactor it.","title":"Core Principles"},{"location":"claude.md/claude_web-application-development-team/#development-workflow","text":"Before making any changes, create and checkout a feature branch named feature-[brief-description] Write comprehensive tests for all new functionality Compile code and run all tests before committing Write detailed commit messages explaining the changes and rationale Commit all changes to the feature branch","title":"Development Workflow"},{"location":"claude.md/claude_web-application-development-team/#architecture-overview","text":"Frontend : Next.js 14 with TypeScript and Tailwind CSS State Management : Zustand for client state, React Query for server state Backend : Node.js with Express and Prisma ORM Database : PostgreSQL Testing : Jest for unit tests, Playwright for E2E","title":"Architecture Overview"},{"location":"claude.md/claude_web-application-development-team/#code-standards","text":"Use TypeScript for all new code with strict type checking Follow the existing component structure in /src/components API routes follow RESTful conventions in /src/pages/api Use Prisma schema definitions for all database operations CSS classes should use Tailwind utilities; custom CSS only when necessary","title":"Code Standards"},{"location":"claude.md/claude_web-application-development-team/#quality-gates","text":"All code must compile without warnings Test coverage must remain above 80% All tests must pass before committing ESLint and Prettier must pass without errors","title":"Quality Gates"},{"location":"claude.md/claude_web-application-development-team/#file-organization","text":"Components: /src/components/[feature]/[ComponentName].tsx Pages: /src/pages/[route].tsx Utilities: /src/lib/[category]/[utility].ts Types: /src/types/[domain].ts","title":"File Organization"},{"location":"commands/","text":"Claude Code Commands These commands can be added to .claude/commands . Example usage: /integrate-parallel-work budget-tracking notifications user-settings","title":"Claude Code Commands"},{"location":"commands/#claude-code-commands","text":"These commands can be added to .claude/commands . Example usage: /integrate-parallel-work budget-tracking notifications user-settings","title":"Claude Code Commands"},{"location":"commands/api-test/","text":"API Testing Command Create comprehensive API tests for: $ARGUMENTS Testing Strategy Test the following API endpoints and scenarios based on $ARGUMENTS: Happy Path Testing : Valid request formats Expected response structures Proper HTTP status codes Error Handling Testing : Invalid request payloads Authentication failures Authorization edge cases Rate limiting scenarios Edge Cases : Boundary value testing Large payload handling Concurrent request handling Network timeout scenarios Test Structure Template Create tests in /tests/api/{endpoint-name}.test.ts : describe('{Endpoint Name} API', () => { describe('POST /{endpoint}', () => { it('should create {resource} with valid data', async () => { // Test implementation }); it('should return 400 for invalid data', async () => { // Test implementation }); it('should require authentication', async () => { // Test implementation }); }); describe('GET /{endpoint}', () => { // Additional test cases }); });","title":"API Test"},{"location":"commands/api-test/#api-testing-command","text":"Create comprehensive API tests for: $ARGUMENTS","title":"API Testing Command"},{"location":"commands/api-test/#testing-strategy","text":"Test the following API endpoints and scenarios based on $ARGUMENTS: Happy Path Testing : Valid request formats Expected response structures Proper HTTP status codes Error Handling Testing : Invalid request payloads Authentication failures Authorization edge cases Rate limiting scenarios Edge Cases : Boundary value testing Large payload handling Concurrent request handling Network timeout scenarios","title":"Testing Strategy"},{"location":"commands/api-test/#test-structure-template","text":"Create tests in /tests/api/{endpoint-name}.test.ts : describe('{Endpoint Name} API', () => { describe('POST /{endpoint}', () => { it('should create {resource} with valid data', async () => { // Test implementation }); it('should return 400 for invalid data', async () => { // Test implementation }); it('should require authentication', async () => { // Test implementation }); }); describe('GET /{endpoint}', () => { // Additional test cases }); });","title":"Test Structure Template"},{"location":"commands/code-review/","text":"Code Review Command Carefully perform a comprehensive code review of $ARGUMENTS. Review Standards Examples of excellent code that you should match the design/style/conventions of: src/components/UserProfile/UserProfile.tsx (React components) src/utils/dataValidation.ts (utility functions) src/hooks/useUserData.ts (custom hooks) Process First : Read the example files above to understand our design patterns, naming conventions, and code style Second : Analyze $ARGUMENTS against these standards Third : Create detailed critique covering: Code structure and organization Adherence to established patterns Performance considerations Security implications Maintainability concerns Test coverage gaps Output Requirements Save review as ai-code-reviews/{filename}.review.md for each file reviewed Include specific line references for issues Provide concrete suggestions for improvements Rate overall quality: Excellent/Good/Needs Improvement/Poor Estimate refactoring effort: Low/Medium/High Review Checklist Follows project naming conventions Proper error handling implemented No hardcoded values, secrets, or magic numbers Appropriate comments and documentation Follows existing design principles and consistent with exemplars No obvious security vulnerabilities Performance optimizations considered","title":"Code Review"},{"location":"commands/code-review/#code-review-command","text":"Carefully perform a comprehensive code review of $ARGUMENTS.","title":"Code Review Command"},{"location":"commands/code-review/#review-standards","text":"Examples of excellent code that you should match the design/style/conventions of: src/components/UserProfile/UserProfile.tsx (React components) src/utils/dataValidation.ts (utility functions) src/hooks/useUserData.ts (custom hooks)","title":"Review Standards"},{"location":"commands/code-review/#process","text":"First : Read the example files above to understand our design patterns, naming conventions, and code style Second : Analyze $ARGUMENTS against these standards Third : Create detailed critique covering: Code structure and organization Adherence to established patterns Performance considerations Security implications Maintainability concerns Test coverage gaps","title":"Process"},{"location":"commands/code-review/#output-requirements","text":"Save review as ai-code-reviews/{filename}.review.md for each file reviewed Include specific line references for issues Provide concrete suggestions for improvements Rate overall quality: Excellent/Good/Needs Improvement/Poor Estimate refactoring effort: Low/Medium/High","title":"Output Requirements"},{"location":"commands/code-review/#review-checklist","text":"Follows project naming conventions Proper error handling implemented No hardcoded values, secrets, or magic numbers Appropriate comments and documentation Follows existing design principles and consistent with exemplars No obvious security vulnerabilities Performance optimizations considered","title":"Review Checklist"},{"location":"commands/document-feature/","text":"Documentation Generator Command Generate comprehensive documentation for feature: $ARGUMENTS Documentation Strategy Create dual-layer documentation based on $ARGUMENTS analysis: Developer Documentation : Technical specifications and architecture API endpoints and data models Implementation details and code examples Configuration and environment setup Testing strategies and debugging notes User Documentation : Step-by-step user guides Visual walkthrough with screenshot placeholders Common use cases and scenarios Troubleshooting and FAQ sections Quick reference guides Feature Detection : Analyze codebase to determine feature type (frontend/backend/full-stack) Identify related components, services, and dependencies Map feature integration points and data flow Detect existing documentation patterns to follow File Analysis Process Code Discovery : Search for files related to $ARGUMENTS in: /src/components/ (React/Vue components) /src/pages/ (Route handlers/pages) /src/api/ or /routes/ (API endpoints) /src/services/ (Business logic) /src/utils/ (Helper functions) /src/hooks/ (Custom hooks) /src/types/ (TypeScript definitions) Documentation Structure Detection : Scan existing /docs/ structure Identify naming conventions and organization patterns Check for existing cross-references and linking patterns Developer Documentation Template Create in /docs/dev/{feature-name}-implementation.md : # {Feature Name} - Technical Implementation ## Overview Brief technical description of the feature and its purpose. ## Architecture - **Type**: [Frontend/Backend/Full-Stack] - **Primary Components**: List of main files and their roles - **Dependencies**: External libraries and internal modules used - **Data Flow**: How data moves through the system ## API Specifications ### Endpoints - `METHOD /api/endpoint` - Description - **Request**: Request format and parameters - **Response**: Response structure and status codes - **Authentication**: Required permissions/roles ### Data Models ```typescript interface FeatureModel { // Type definitions } Implementation Details Key Components Component Name ( path/to/file.ts ): Purpose and functionality Service Layer ( path/to/service.ts ): Business logic implementation Database Layer ( path/to/model.ts ): Data persistence details Configuration Environment variables and configuration options required. Security Considerations Authentication, authorization, and data validation requirements. Testing Unit Tests : tests/unit/{feature}.test.ts Integration Tests : tests/integration/{feature}.test.ts API Tests : tests/api/{feature}.test.ts Debugging Guide Common issues and debugging strategies for developers. Related Documentation Link to user documentation Related feature documentation ## User Documentation Template Create in `/docs/user/how-to-{feature-name}.md`: ```markdown # How to Use {Feature Name} ## Overview Simple explanation of what this feature does and why users would want to use it. ## Quick Start 1. **Step 1**: Basic action description ![Screenshot placeholder: Initial state] 2. **Step 2**: Next action with visual guide ![Screenshot placeholder: Action in progress] 3. **Step 3**: Final result ![Screenshot placeholder: Completed state] ## Detailed Guide ### Getting Started Prerequisites and initial setup instructions. ### Step-by-Step Instructions #### Task 1: {Primary Use Case} 1. Navigate to [specific location] ![Screenshot placeholder: Navigation step] 2. Click [specific button/element] ![Screenshot placeholder: Button/element highlighted] 3. Fill in the required information: - **Field 1**: What to enter and why - **Field 2**: Expected format or options ![Screenshot placeholder: Form completion] 4. Confirm your action ![Screenshot placeholder: Confirmation dialog] #### Task 2: {Secondary Use Case} [Additional scenarios and use cases] ## Common Scenarios ### Scenario 1: {Common Use Case} When you want to [goal], follow these steps: 1. [Step with visual cue] 2. [Step with expected outcome] ### Scenario 2: {Edge Case Handling} If you encounter [situation], here's how to handle it: 1. [Troubleshooting step] 2. [Alternative approach] ## Troubleshooting ### Problem: {Common Issue} **Symptoms**: What the user sees **Solution**: Step-by-step fix **Prevention**: How to avoid in future ### Problem: {Another Issue} **Symptoms**: Error messages or behavior **Solution**: Resolution steps **When to contact support**: Escalation criteria ## FAQ **Q: {Common Question}** A: Clear, concise answer with links to relevant sections. **Q: {Technical Question}** A: User-friendly explanation avoiding technical jargon. ## Quick Reference - **Keyboard Shortcuts**: List of useful shortcuts - **Important Links**: Quick access to key features - **Related Features**: Links to complementary functionality ## Need Help? - [Developer Documentation](../dev/{feature-name}-implementation.md) (for technical details) - [Support Contact Information] - [Community Forums/Resources] Cross-Reference Generation Automatically create bidirectional links between: - Developer docs \u2194 User docs - Feature docs \u2194 Related feature docs - API docs \u2194 Implementation examples - Troubleshooting guides \u2194 Technical solutions Screenshot Automation Strategy For user documentation: Placeholder Format : ![Screenshot placeholder: {descriptive-action}] Naming Convention : screenshots/{feature-name}/{step-number}-{action-description}.png Auto-capture Instructions : Include comments for future screenshot automation Alternative Text : Provide descriptive alt text for accessibility Documentation Quality Checklist [ ] Both dev and user docs created [ ] Cross-references properly linked [ ] Screenshots placeholders positioned appropriately [ ] Code examples are functional and tested [ ] API documentation matches actual implementation [ ] User instructions tested by non-technical reviewer [ ] Troubleshooting section covers common issues [ ] Related documentation updated with new feature references Output Structure docs/ \u251c\u2500\u2500 dev/ \u2502 \u2514\u2500\u2500 {feature-name}-implementation.md \u251c\u2500\u2500 user/ \u2502 \u2514\u2500\u2500 how-to-{feature-name}.md \u2514\u2500\u2500 screenshots/ \u2514\u2500\u2500 {feature-name}/ \u251c\u2500\u2500 step-1-navigation.png (placeholder) \u251c\u2500\u2500 step-2-action.png (placeholder) \u2514\u2500\u2500 step-3-result.png (placeholder) Feature Type Detection Guide Frontend Only : Components, hooks, UI logic Backend Only : APIs, services, database models Full-Stack : Both frontend and backend components with data flow Adjust documentation depth and technical detail based on detected feature type.","title":"Document Feature"},{"location":"commands/document-feature/#documentation-generator-command","text":"Generate comprehensive documentation for feature: $ARGUMENTS","title":"Documentation Generator Command"},{"location":"commands/document-feature/#documentation-strategy","text":"Create dual-layer documentation based on $ARGUMENTS analysis: Developer Documentation : Technical specifications and architecture API endpoints and data models Implementation details and code examples Configuration and environment setup Testing strategies and debugging notes User Documentation : Step-by-step user guides Visual walkthrough with screenshot placeholders Common use cases and scenarios Troubleshooting and FAQ sections Quick reference guides Feature Detection : Analyze codebase to determine feature type (frontend/backend/full-stack) Identify related components, services, and dependencies Map feature integration points and data flow Detect existing documentation patterns to follow","title":"Documentation Strategy"},{"location":"commands/document-feature/#file-analysis-process","text":"Code Discovery : Search for files related to $ARGUMENTS in: /src/components/ (React/Vue components) /src/pages/ (Route handlers/pages) /src/api/ or /routes/ (API endpoints) /src/services/ (Business logic) /src/utils/ (Helper functions) /src/hooks/ (Custom hooks) /src/types/ (TypeScript definitions) Documentation Structure Detection : Scan existing /docs/ structure Identify naming conventions and organization patterns Check for existing cross-references and linking patterns","title":"File Analysis Process"},{"location":"commands/document-feature/#developer-documentation-template","text":"Create in /docs/dev/{feature-name}-implementation.md : # {Feature Name} - Technical Implementation ## Overview Brief technical description of the feature and its purpose. ## Architecture - **Type**: [Frontend/Backend/Full-Stack] - **Primary Components**: List of main files and their roles - **Dependencies**: External libraries and internal modules used - **Data Flow**: How data moves through the system ## API Specifications ### Endpoints - `METHOD /api/endpoint` - Description - **Request**: Request format and parameters - **Response**: Response structure and status codes - **Authentication**: Required permissions/roles ### Data Models ```typescript interface FeatureModel { // Type definitions }","title":"Developer Documentation Template"},{"location":"commands/document-feature/#implementation-details","text":"","title":"Implementation Details"},{"location":"commands/document-feature/#key-components","text":"Component Name ( path/to/file.ts ): Purpose and functionality Service Layer ( path/to/service.ts ): Business logic implementation Database Layer ( path/to/model.ts ): Data persistence details","title":"Key Components"},{"location":"commands/document-feature/#configuration","text":"Environment variables and configuration options required.","title":"Configuration"},{"location":"commands/document-feature/#security-considerations","text":"Authentication, authorization, and data validation requirements.","title":"Security Considerations"},{"location":"commands/document-feature/#testing","text":"Unit Tests : tests/unit/{feature}.test.ts Integration Tests : tests/integration/{feature}.test.ts API Tests : tests/api/{feature}.test.ts","title":"Testing"},{"location":"commands/document-feature/#debugging-guide","text":"Common issues and debugging strategies for developers.","title":"Debugging Guide"},{"location":"commands/document-feature/#related-documentation","text":"Link to user documentation Related feature documentation ## User Documentation Template Create in `/docs/user/how-to-{feature-name}.md`: ```markdown # How to Use {Feature Name} ## Overview Simple explanation of what this feature does and why users would want to use it. ## Quick Start 1. **Step 1**: Basic action description ![Screenshot placeholder: Initial state] 2. **Step 2**: Next action with visual guide ![Screenshot placeholder: Action in progress] 3. **Step 3**: Final result ![Screenshot placeholder: Completed state] ## Detailed Guide ### Getting Started Prerequisites and initial setup instructions. ### Step-by-Step Instructions #### Task 1: {Primary Use Case} 1. Navigate to [specific location] ![Screenshot placeholder: Navigation step] 2. Click [specific button/element] ![Screenshot placeholder: Button/element highlighted] 3. Fill in the required information: - **Field 1**: What to enter and why - **Field 2**: Expected format or options ![Screenshot placeholder: Form completion] 4. Confirm your action ![Screenshot placeholder: Confirmation dialog] #### Task 2: {Secondary Use Case} [Additional scenarios and use cases] ## Common Scenarios ### Scenario 1: {Common Use Case} When you want to [goal], follow these steps: 1. [Step with visual cue] 2. [Step with expected outcome] ### Scenario 2: {Edge Case Handling} If you encounter [situation], here's how to handle it: 1. [Troubleshooting step] 2. [Alternative approach] ## Troubleshooting ### Problem: {Common Issue} **Symptoms**: What the user sees **Solution**: Step-by-step fix **Prevention**: How to avoid in future ### Problem: {Another Issue} **Symptoms**: Error messages or behavior **Solution**: Resolution steps **When to contact support**: Escalation criteria ## FAQ **Q: {Common Question}** A: Clear, concise answer with links to relevant sections. **Q: {Technical Question}** A: User-friendly explanation avoiding technical jargon. ## Quick Reference - **Keyboard Shortcuts**: List of useful shortcuts - **Important Links**: Quick access to key features - **Related Features**: Links to complementary functionality ## Need Help? - [Developer Documentation](../dev/{feature-name}-implementation.md) (for technical details) - [Support Contact Information] - [Community Forums/Resources]","title":"Related Documentation"},{"location":"commands/document-feature/#cross-reference-generation","text":"Automatically create bidirectional links between: - Developer docs \u2194 User docs - Feature docs \u2194 Related feature docs - API docs \u2194 Implementation examples - Troubleshooting guides \u2194 Technical solutions","title":"Cross-Reference Generation"},{"location":"commands/document-feature/#screenshot-automation-strategy","text":"For user documentation: Placeholder Format : ![Screenshot placeholder: {descriptive-action}] Naming Convention : screenshots/{feature-name}/{step-number}-{action-description}.png Auto-capture Instructions : Include comments for future screenshot automation Alternative Text : Provide descriptive alt text for accessibility","title":"Screenshot Automation Strategy"},{"location":"commands/document-feature/#documentation-quality-checklist","text":"[ ] Both dev and user docs created [ ] Cross-references properly linked [ ] Screenshots placeholders positioned appropriately [ ] Code examples are functional and tested [ ] API documentation matches actual implementation [ ] User instructions tested by non-technical reviewer [ ] Troubleshooting section covers common issues [ ] Related documentation updated with new feature references","title":"Documentation Quality Checklist"},{"location":"commands/document-feature/#output-structure","text":"docs/ \u251c\u2500\u2500 dev/ \u2502 \u2514\u2500\u2500 {feature-name}-implementation.md \u251c\u2500\u2500 user/ \u2502 \u2514\u2500\u2500 how-to-{feature-name}.md \u2514\u2500\u2500 screenshots/ \u2514\u2500\u2500 {feature-name}/ \u251c\u2500\u2500 step-1-navigation.png (placeholder) \u251c\u2500\u2500 step-2-action.png (placeholder) \u2514\u2500\u2500 step-3-result.png (placeholder)","title":"Output Structure"},{"location":"commands/document-feature/#feature-type-detection-guide","text":"Frontend Only : Components, hooks, UI logic Backend Only : APIs, services, database models Full-Stack : Both frontend and backend components with data flow Adjust documentation depth and technical detail based on detected feature type.","title":"Feature Type Detection Guide"},{"location":"commands/integrate-parallel-work/","text":"I have features developed in parallel worktrees that I need to integrate: $ARGUMENTS Please help me integrate these features: Create a new integration branch called \"integration/parallel-features\" For each feature name provided, merge the branch feature/[feature-name] into the integration branch Resolve any merge conflicts that arise Test that all features work together Run all tests to ensure nothing is broken Once integration is successful, merge to main and clean up branches I want to integrate these safely before merging to main.","title":"Integrate Parallel Work"},{"location":"commands/parallel-agents/","text":"Parallel Agents Command I want to develop features in parallel using Git worktrees and subagents: $ARGUMENTS You are in the parent folder of the main repo. You will need to change to the main repo folder to create the worktrees. Please execute this complete workflow: PHASE 1 - SETUP WORKTREES: For each feature mentioned: Create a worktree at ../expense-tracker-[feature-name] with branch feature/[feature-name] Set up the development environment in each worktree (if needed) List all worktrees created PHASE 2 - SPAWN SUBAGENTS: For each feature, run a subagent in parallel with these instructions: You are working in the expense-tracker-[feature-name] worktree directory This is a completely isolated development environment Implement the [feature-name] feature with full functionality Include proper testing and error handling Compile and run tests, but don't attempt to run the application (e.g., don't do \"npm run\" or \"npm run dev &\", etc.) When complete, write a detailed summary in [feature-name].work.txt in the main expense-tracker-ai directory The summary should include: what was implemented, files created/modified, dependencies added, testing approach, and integration notes PHASE 3 - COORDINATION: Monitor all subagents working in parallel Ensure each subagent completes their feature implementation Verify each subagent creates their work summary file PHASE 4 - FINAL SUMMARY: After all subagents complete: Read all the .work.txt files created by subagents Provide a comprehensive summary of what was accomplished List all features implemented and their status Provide next steps for integration Execute this complete parallel development workflow.","title":"Parallel Agents"},{"location":"commands/parallel-agents/#parallel-agents-command","text":"I want to develop features in parallel using Git worktrees and subagents: $ARGUMENTS You are in the parent folder of the main repo. You will need to change to the main repo folder to create the worktrees. Please execute this complete workflow:","title":"Parallel Agents Command"},{"location":"commands/parallel-agents/#phase-1-setup-worktrees","text":"For each feature mentioned: Create a worktree at ../expense-tracker-[feature-name] with branch feature/[feature-name] Set up the development environment in each worktree (if needed) List all worktrees created","title":"PHASE 1 - SETUP WORKTREES:"},{"location":"commands/parallel-agents/#phase-2-spawn-subagents","text":"For each feature, run a subagent in parallel with these instructions: You are working in the expense-tracker-[feature-name] worktree directory This is a completely isolated development environment Implement the [feature-name] feature with full functionality Include proper testing and error handling Compile and run tests, but don't attempt to run the application (e.g., don't do \"npm run\" or \"npm run dev &\", etc.) When complete, write a detailed summary in [feature-name].work.txt in the main expense-tracker-ai directory The summary should include: what was implemented, files created/modified, dependencies added, testing approach, and integration notes","title":"PHASE 2 - SPAWN SUBAGENTS:"},{"location":"commands/parallel-agents/#phase-3-coordination","text":"Monitor all subagents working in parallel Ensure each subagent completes their feature implementation Verify each subagent creates their work summary file","title":"PHASE 3 - COORDINATION:"},{"location":"commands/parallel-agents/#phase-4-final-summary","text":"After all subagents complete: Read all the .work.txt files created by subagents Provide a comprehensive summary of what was accomplished List all features implemented and their status Provide next steps for integration Execute this complete parallel development workflow.","title":"PHASE 4 - FINAL SUMMARY:"},{"location":"commands/parallel-work/","text":"I want to develop features in parallel for my expense tracker app using Git worktrees: $ARGUMENTS Think about how to divide the work up into separate features unless this has been clearly explained already. Please help me set up the worktree environment: For each feature mentioned, create a worktree at ../expense-tracker-[feature-name] with branch feature/[feature-name] Set up the development environment in each worktree List all worktrees to confirm they were created Explain what each worktree will contain and how they're isolated I want to be able to work on all features simultaneously without conflicts.","title":"Parallel Work"}]}