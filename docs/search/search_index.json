{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Claude.md Examples This is a collection of example claude.md files for Claude Code. The raw markdown files are available at `github.com/grokify/claude-md Build-Lint Check DevOps Infrastructure Project Enterprise Backend Service Mobile App Development - React Native Open Soruce Liberary Development Python Data Science Project Web Application Development Team","title":"Home"},{"location":"#claudemd-examples","text":"This is a collection of example claude.md files for Claude Code. The raw markdown files are available at `github.com/grokify/claude-md Build-Lint Check DevOps Infrastructure Project Enterprise Backend Service Mobile App Development - React Native Open Soruce Liberary Development Python Data Science Project Web Application Development Team","title":"Claude.md Examples"},{"location":"claude_build-lint-check/","text":"Build-Lint Check From: https://www.reddit.com/r/ClaudeAI/comments/1ko5pxk/comment/msohsxt/ Critical Rules - DO NOT VIOLATE NEVER create mock data or simplified components unless explicitly told to do so NEVER replace existing complex components with simplified versions - always fix the actual problem ALWAYS work with the existing codebase - do not create new simplified alternatives ALWAYS find and fix the root cause of issues instead of creating workarounds When debugging issues, focus on fixing the existing implementation, not replacing it When something doesn't work, debug and fix it - don't start over with a simple version ALWAYS check MUI X v8 AND MUI v7 DOCS before making changes to MUI-related components - they have breaking changes TypeScript and Linting ALWAYS add explicit types to all function parameters, variables, and return types ALWAYS run pnpm build or appropriate linter command before considering any code changes complete Fix all linter and TypeScript errors immediately - don't leave them for the user to fix When making changes to multiple files, check each one for type errors Prisma Usage NEVER use raw SQL queries ($queryRaw, $queryRawUnsafe) - always use Prisma Client methods When relations don't exist in the schema, use separate queries with findMany() and create lookup maps Always check the Prisma schema before assuming relations exist MUI Component Guidelines ALWAYS check MUI X v8 AND MUI V7 DOCS before making changes to related components. They are very new versions and likely have breaking changes you do not know about.","title":"Build-Lint Check"},{"location":"claude_build-lint-check/#build-lint-check","text":"From: https://www.reddit.com/r/ClaudeAI/comments/1ko5pxk/comment/msohsxt/","title":"Build-Lint Check"},{"location":"claude_build-lint-check/#critical-rules-do-not-violate","text":"NEVER create mock data or simplified components unless explicitly told to do so NEVER replace existing complex components with simplified versions - always fix the actual problem ALWAYS work with the existing codebase - do not create new simplified alternatives ALWAYS find and fix the root cause of issues instead of creating workarounds When debugging issues, focus on fixing the existing implementation, not replacing it When something doesn't work, debug and fix it - don't start over with a simple version ALWAYS check MUI X v8 AND MUI v7 DOCS before making changes to MUI-related components - they have breaking changes","title":"Critical Rules - DO NOT VIOLATE"},{"location":"claude_build-lint-check/#typescript-and-linting","text":"ALWAYS add explicit types to all function parameters, variables, and return types ALWAYS run pnpm build or appropriate linter command before considering any code changes complete Fix all linter and TypeScript errors immediately - don't leave them for the user to fix When making changes to multiple files, check each one for type errors","title":"TypeScript and Linting"},{"location":"claude_build-lint-check/#prisma-usage","text":"NEVER use raw SQL queries ($queryRaw, $queryRawUnsafe) - always use Prisma Client methods When relations don't exist in the schema, use separate queries with findMany() and create lookup maps Always check the Prisma schema before assuming relations exist","title":"Prisma Usage"},{"location":"claude_build-lint-check/#mui-component-guidelines","text":"ALWAYS check MUI X v8 AND MUI V7 DOCS before making changes to related components. They are very new versions and likely have breaking changes you do not know about.","title":"MUI Component Guidelines"},{"location":"claude_devops-infrastructure-project/","text":"Project: Multi-Cloud Infrastructure Platform Infrastructure as Code Standards Primary Tool : Terraform with HCL Cloud Providers : AWS, Azure, GCP Configuration Management : Ansible playbooks Container Orchestration : Kubernetes with Helm charts Monitoring : Prometheus, Grafana, ELK stack Workflow Requirements Create infrastructure branch: infra-[environment]-[component] Run terraform plan and review changes carefully Test in development environment first Update documentation in /docs/runbooks Peer review required for production changes Use conventional commits with clear impact description Directory Structure /terraform/[provider]/[environment]/ : Environment-specific configurations /ansible/playbooks/ : Configuration management scripts /k8s/[namespace]/ : Kubernetes manifests and Helm charts /scripts/ : Automation and deployment scripts /docs/ : Architecture decisions and runbooks Security and Compliance All secrets must use external secret management (AWS Secrets Manager, etc.) Enable encryption at rest and in transit for all data stores Implement least-privilege access policies Use service accounts, never personal credentials in automation Maintain audit logs for all infrastructure changes Deployment Principles Use blue-green deployments for zero-downtime updates Implement automatic rollback on health check failures Tag all resources with environment, owner, and cost-center Use infrastructure modules for reusability across environments Implement proper backup and disaster recovery procedures Monitoring and Alerting Set up alerts for resource utilization > 80% Monitor certificate expiration dates Track deployment success/failure rates Implement SLA monitoring for critical services Use runbooks for common incident response procedures Cost Optimization Implement auto-scaling policies for dynamic workloads Use spot instances where appropriate for non-critical workloads Regular cost reviews with resource rightsizing Implement resource lifecycle policies for cleanup","title":"DevOps Infrastructure Project"},{"location":"claude_devops-infrastructure-project/#project-multi-cloud-infrastructure-platform","text":"","title":"Project: Multi-Cloud Infrastructure Platform"},{"location":"claude_devops-infrastructure-project/#infrastructure-as-code-standards","text":"Primary Tool : Terraform with HCL Cloud Providers : AWS, Azure, GCP Configuration Management : Ansible playbooks Container Orchestration : Kubernetes with Helm charts Monitoring : Prometheus, Grafana, ELK stack","title":"Infrastructure as Code Standards"},{"location":"claude_devops-infrastructure-project/#workflow-requirements","text":"Create infrastructure branch: infra-[environment]-[component] Run terraform plan and review changes carefully Test in development environment first Update documentation in /docs/runbooks Peer review required for production changes Use conventional commits with clear impact description","title":"Workflow Requirements"},{"location":"claude_devops-infrastructure-project/#directory-structure","text":"/terraform/[provider]/[environment]/ : Environment-specific configurations /ansible/playbooks/ : Configuration management scripts /k8s/[namespace]/ : Kubernetes manifests and Helm charts /scripts/ : Automation and deployment scripts /docs/ : Architecture decisions and runbooks","title":"Directory Structure"},{"location":"claude_devops-infrastructure-project/#security-and-compliance","text":"All secrets must use external secret management (AWS Secrets Manager, etc.) Enable encryption at rest and in transit for all data stores Implement least-privilege access policies Use service accounts, never personal credentials in automation Maintain audit logs for all infrastructure changes","title":"Security and Compliance"},{"location":"claude_devops-infrastructure-project/#deployment-principles","text":"Use blue-green deployments for zero-downtime updates Implement automatic rollback on health check failures Tag all resources with environment, owner, and cost-center Use infrastructure modules for reusability across environments Implement proper backup and disaster recovery procedures","title":"Deployment Principles"},{"location":"claude_devops-infrastructure-project/#monitoring-and-alerting","text":"Set up alerts for resource utilization > 80% Monitor certificate expiration dates Track deployment success/failure rates Implement SLA monitoring for critical services Use runbooks for common incident response procedures","title":"Monitoring and Alerting"},{"location":"claude_devops-infrastructure-project/#cost-optimization","text":"Implement auto-scaling policies for dynamic workloads Use spot instances where appropriate for non-critical workloads Regular cost reviews with resource rightsizing Implement resource lifecycle policies for cleanup","title":"Cost Optimization"},{"location":"claude_enterprise-backend-service/","text":"Project: Payment Processing Microservice Service Architecture Framework : Spring Boot 3.1 with Java 17 Database : PostgreSQL with JPA/Hibernate Security : OAuth 2.0 with JWT tokens Documentation : OpenAPI 3.0 specifications Deployment : Docker containers with Kubernetes Development Workflow Create feature branch: backend-[ticket-number]-[description] Write integration tests for all new endpoints Update OpenAPI documentation for API changes Run full test suite: ./gradlew test integrationTest Ensure Docker build succeeds: docker build -t payment-service . Commit with ticket reference: feat: [TICKET-123] Add payment validation Code Standards Follow Google Java Style Guide Use Spring Boot conventions for package structure All REST endpoints must have comprehensive validation Use DTOs for all external API contracts Implement proper exception handling with @ControllerAdvice Package Structure controller : REST endpoints and request/response handling service : Business logic and transaction management repository : Data access layer with JPA repositories config : Configuration classes and beans dto : Data Transfer Objects for API contracts entity : JPA entities for database mapping exception : Custom exceptions and error handling Security Requirements All endpoints require authentication except health checks Validate all inputs with Bean Validation annotations Use parameterized queries to prevent SQL injection Log security events for audit trail Never expose internal entity models in API responses Quality Gates Minimum 85% test coverage (unit + integration) All dependencies must be up-to-date and vulnerability-free SonarQube quality gate must pass All database migrations must be reversible Performance tests must complete under 200ms for standard operations Monitoring and Logging Use structured logging with JSON format Include correlation IDs for request tracing Monitor key metrics: response time, error rate, throughput Implement health checks for Kubernetes readiness/liveness probes","title":"Enterprise Backend Service"},{"location":"claude_enterprise-backend-service/#project-payment-processing-microservice","text":"","title":"Project: Payment Processing Microservice"},{"location":"claude_enterprise-backend-service/#service-architecture","text":"Framework : Spring Boot 3.1 with Java 17 Database : PostgreSQL with JPA/Hibernate Security : OAuth 2.0 with JWT tokens Documentation : OpenAPI 3.0 specifications Deployment : Docker containers with Kubernetes","title":"Service Architecture"},{"location":"claude_enterprise-backend-service/#development-workflow","text":"Create feature branch: backend-[ticket-number]-[description] Write integration tests for all new endpoints Update OpenAPI documentation for API changes Run full test suite: ./gradlew test integrationTest Ensure Docker build succeeds: docker build -t payment-service . Commit with ticket reference: feat: [TICKET-123] Add payment validation","title":"Development Workflow"},{"location":"claude_enterprise-backend-service/#code-standards","text":"Follow Google Java Style Guide Use Spring Boot conventions for package structure All REST endpoints must have comprehensive validation Use DTOs for all external API contracts Implement proper exception handling with @ControllerAdvice","title":"Code Standards"},{"location":"claude_enterprise-backend-service/#package-structure","text":"controller : REST endpoints and request/response handling service : Business logic and transaction management repository : Data access layer with JPA repositories config : Configuration classes and beans dto : Data Transfer Objects for API contracts entity : JPA entities for database mapping exception : Custom exceptions and error handling","title":"Package Structure"},{"location":"claude_enterprise-backend-service/#security-requirements","text":"All endpoints require authentication except health checks Validate all inputs with Bean Validation annotations Use parameterized queries to prevent SQL injection Log security events for audit trail Never expose internal entity models in API responses","title":"Security Requirements"},{"location":"claude_enterprise-backend-service/#quality-gates","text":"Minimum 85% test coverage (unit + integration) All dependencies must be up-to-date and vulnerability-free SonarQube quality gate must pass All database migrations must be reversible Performance tests must complete under 200ms for standard operations","title":"Quality Gates"},{"location":"claude_enterprise-backend-service/#monitoring-and-logging","text":"Use structured logging with JSON format Include correlation IDs for request tracing Monitor key metrics: response time, error rate, throughput Implement health checks for Kubernetes readiness/liveness probes","title":"Monitoring and Logging"},{"location":"claude_mobile-app-development-react-native/","text":"Project: FitnessTracker Mobile App Platform Requirements Framework : React Native 0.72+ with TypeScript State Management : Redux Toolkit with RTK Query Navigation : React Navigation v6 UI Library : Native Base for consistent design Platform Support : iOS 14+ and Android API 24+ Branch Strategy Create feature branches: mobile-[feature-name] Use conventional commits: feat: , fix: , refactor: , etc. Test on both iOS and Android before committing Run npm run lint and npm run type-check before commits Code Organization Screens : /src/screens/[FeatureName]/[ScreenName]Screen.tsx Components : /src/components/[ComponentName]/index.tsx Navigation : /src/navigation/[NavigatorName]Navigator.tsx Services : /src/services/[serviceName].ts Store : /src/store/slices/[featureName]Slice.ts Mobile-Specific Standards Use React Native's built-in components before third-party libraries Implement proper error boundaries for crash prevention Use AsyncStorage for local data persistence Follow platform-specific design guidelines (iOS Human Interface, Material Design) Optimize images and use vector graphics when possible Testing Requirements Unit tests with Jest and React Native Testing Library E2E tests with Detox for critical user flows Test on physical devices before major releases Performance testing with Flipper profiling Performance Guidelines Use FlatList for large datasets, never ScrollView Implement proper memoization with React.memo and useMemo Lazy load heavy components and screens Monitor bundle size and use code splitting when necessary","title":"Mobile App Development - React Native"},{"location":"claude_mobile-app-development-react-native/#project-fitnesstracker-mobile-app","text":"","title":"Project: FitnessTracker Mobile App"},{"location":"claude_mobile-app-development-react-native/#platform-requirements","text":"Framework : React Native 0.72+ with TypeScript State Management : Redux Toolkit with RTK Query Navigation : React Navigation v6 UI Library : Native Base for consistent design Platform Support : iOS 14+ and Android API 24+","title":"Platform Requirements"},{"location":"claude_mobile-app-development-react-native/#branch-strategy","text":"Create feature branches: mobile-[feature-name] Use conventional commits: feat: , fix: , refactor: , etc. Test on both iOS and Android before committing Run npm run lint and npm run type-check before commits","title":"Branch Strategy"},{"location":"claude_mobile-app-development-react-native/#code-organization","text":"Screens : /src/screens/[FeatureName]/[ScreenName]Screen.tsx Components : /src/components/[ComponentName]/index.tsx Navigation : /src/navigation/[NavigatorName]Navigator.tsx Services : /src/services/[serviceName].ts Store : /src/store/slices/[featureName]Slice.ts","title":"Code Organization"},{"location":"claude_mobile-app-development-react-native/#mobile-specific-standards","text":"Use React Native's built-in components before third-party libraries Implement proper error boundaries for crash prevention Use AsyncStorage for local data persistence Follow platform-specific design guidelines (iOS Human Interface, Material Design) Optimize images and use vector graphics when possible","title":"Mobile-Specific Standards"},{"location":"claude_mobile-app-development-react-native/#testing-requirements","text":"Unit tests with Jest and React Native Testing Library E2E tests with Detox for critical user flows Test on physical devices before major releases Performance testing with Flipper profiling","title":"Testing Requirements"},{"location":"claude_mobile-app-development-react-native/#performance-guidelines","text":"Use FlatList for large datasets, never ScrollView Implement proper memoization with React.memo and useMemo Lazy load heavy components and screens Monitor bundle size and use code splitting when necessary","title":"Performance Guidelines"},{"location":"claude_open-source-library-development/","text":"Project: DataValidator - Python Data Validation Library Library Design Principles API Design : Simple, intuitive, and Pythonic Dependencies : Minimal external dependencies Compatibility : Python 3.8+ support Performance : Optimize for speed and memory efficiency Documentation : Comprehensive with examples Development Workflow Create feature branch: feature-[functionality] or fix-[issue-number] Write tests first (TDD approach) Ensure 100% test coverage for new code Update documentation and examples Run full test suite across Python versions: tox Update CHANGELOG.md with clear user-facing description Code Quality Standards Follow PEP 8 with line length limit of 88 characters Use type hints for all public APIs Docstrings required for all public functions/classes (Google style) Use dataclasses or Pydantic for structured data Implement proper error handling with custom exceptions Project Structure /src/datavalidator/ : Main library code /tests/ : Comprehensive test suite /docs/ : Sphinx documentation /examples/ : Usage examples and tutorials /benchmarks/ : Performance testing scripts Testing Requirements Unit tests with pytest for all functionality Property-based testing with Hypothesis for edge cases Performance benchmarks for critical paths Integration tests with popular data libraries (pandas, numpy) Test matrix: Python 3.8, 3.9, 3.10, 3.11, 3.12 Documentation Standards README with quick start guide and installation API documentation generated from docstrings Tutorial notebooks for common use cases Performance guidelines and best practices Migration guides for major version changes Release Process Semantic versioning (MAJOR.MINOR.PATCH) Automated testing on multiple Python versions Code coverage reports and quality metrics Security scanning for vulnerabilities Automated PyPI releases via GitHub Actions Community Guidelines Welcome contributions with clear CONTRIBUTING.md Issue templates for bugs and feature requests Code of conduct for inclusive community Regular maintenance and dependency updates Responsive to community feedback and issues","title":"Open Soruce Liberary Development"},{"location":"claude_open-source-library-development/#project-datavalidator-python-data-validation-library","text":"","title":"Project: DataValidator - Python Data Validation Library"},{"location":"claude_open-source-library-development/#library-design-principles","text":"API Design : Simple, intuitive, and Pythonic Dependencies : Minimal external dependencies Compatibility : Python 3.8+ support Performance : Optimize for speed and memory efficiency Documentation : Comprehensive with examples","title":"Library Design Principles"},{"location":"claude_open-source-library-development/#development-workflow","text":"Create feature branch: feature-[functionality] or fix-[issue-number] Write tests first (TDD approach) Ensure 100% test coverage for new code Update documentation and examples Run full test suite across Python versions: tox Update CHANGELOG.md with clear user-facing description","title":"Development Workflow"},{"location":"claude_open-source-library-development/#code-quality-standards","text":"Follow PEP 8 with line length limit of 88 characters Use type hints for all public APIs Docstrings required for all public functions/classes (Google style) Use dataclasses or Pydantic for structured data Implement proper error handling with custom exceptions","title":"Code Quality Standards"},{"location":"claude_open-source-library-development/#project-structure","text":"/src/datavalidator/ : Main library code /tests/ : Comprehensive test suite /docs/ : Sphinx documentation /examples/ : Usage examples and tutorials /benchmarks/ : Performance testing scripts","title":"Project Structure"},{"location":"claude_open-source-library-development/#testing-requirements","text":"Unit tests with pytest for all functionality Property-based testing with Hypothesis for edge cases Performance benchmarks for critical paths Integration tests with popular data libraries (pandas, numpy) Test matrix: Python 3.8, 3.9, 3.10, 3.11, 3.12","title":"Testing Requirements"},{"location":"claude_open-source-library-development/#documentation-standards","text":"README with quick start guide and installation API documentation generated from docstrings Tutorial notebooks for common use cases Performance guidelines and best practices Migration guides for major version changes","title":"Documentation Standards"},{"location":"claude_open-source-library-development/#release-process","text":"Semantic versioning (MAJOR.MINOR.PATCH) Automated testing on multiple Python versions Code coverage reports and quality metrics Security scanning for vulnerabilities Automated PyPI releases via GitHub Actions","title":"Release Process"},{"location":"claude_open-source-library-development/#community-guidelines","text":"Welcome contributions with clear CONTRIBUTING.md Issue templates for bugs and feature requests Code of conduct for inclusive community Regular maintenance and dependency updates Responsive to community feedback and issues","title":"Community Guidelines"},{"location":"claude_python-data-science-project/","text":"Project: Customer Analytics Pipeline Development Standards Language : Python 3.11+ Code Style : Follow PEP 8 strictly, use Black for formatting Type Hints : Required for all function signatures and class definitions Documentation : Docstrings required for all public functions and classes Workflow Requirements Create feature branch: analysis-[description] or model-[description] Write unit tests for all data processing functions Run pytest and ensure all tests pass Run black . and flake8 before committing Update relevant documentation in /docs if adding new features Project Structure /src/data : Data ingestion and preprocessing modules /src/models : ML model definitions and training scripts /src/analysis : Exploratory analysis notebooks and scripts /src/utils : Shared utility functions /tests : Comprehensive test suite /configs : Configuration files for different environments Data Handling Standards Use Pandas for data manipulation, prefer vectorized operations All data files must be documented in /data/README.md Use Pydantic models for data validation and serialization Never commit raw data files to version control Use environment variables for database connections and API keys ML/Analysis Guidelines Use scikit-learn for standard ML algorithms Notebook naming: YYYY-MM-DD-[initials]-[description].ipynb Save all trained models with versioning in /models/trained Use MLflow for experiment tracking Include model performance metrics in commit messages Dependencies Core: pandas, numpy, scikit-learn, matplotlib, seaborn ML: xgboost, lightgbm, optuna Data: sqlalchemy, pydantic, requests Testing: pytest, pytest-cov","title":"Python Data Science Project"},{"location":"claude_python-data-science-project/#project-customer-analytics-pipeline","text":"","title":"Project: Customer Analytics Pipeline"},{"location":"claude_python-data-science-project/#development-standards","text":"Language : Python 3.11+ Code Style : Follow PEP 8 strictly, use Black for formatting Type Hints : Required for all function signatures and class definitions Documentation : Docstrings required for all public functions and classes","title":"Development Standards"},{"location":"claude_python-data-science-project/#workflow-requirements","text":"Create feature branch: analysis-[description] or model-[description] Write unit tests for all data processing functions Run pytest and ensure all tests pass Run black . and flake8 before committing Update relevant documentation in /docs if adding new features","title":"Workflow Requirements"},{"location":"claude_python-data-science-project/#project-structure","text":"/src/data : Data ingestion and preprocessing modules /src/models : ML model definitions and training scripts /src/analysis : Exploratory analysis notebooks and scripts /src/utils : Shared utility functions /tests : Comprehensive test suite /configs : Configuration files for different environments","title":"Project Structure"},{"location":"claude_python-data-science-project/#data-handling-standards","text":"Use Pandas for data manipulation, prefer vectorized operations All data files must be documented in /data/README.md Use Pydantic models for data validation and serialization Never commit raw data files to version control Use environment variables for database connections and API keys","title":"Data Handling Standards"},{"location":"claude_python-data-science-project/#mlanalysis-guidelines","text":"Use scikit-learn for standard ML algorithms Notebook naming: YYYY-MM-DD-[initials]-[description].ipynb Save all trained models with versioning in /models/trained Use MLflow for experiment tracking Include model performance metrics in commit messages","title":"ML/Analysis Guidelines"},{"location":"claude_python-data-science-project/#dependencies","text":"Core: pandas, numpy, scikit-learn, matplotlib, seaborn ML: xgboost, lightgbm, optuna Data: sqlalchemy, pydantic, requests Testing: pytest, pytest-cov","title":"Dependencies"},{"location":"claude_web-application-development-team/","text":"Project: TaskFlow Web Application Core Principles IMPORTANT : Whenever you write code, it MUST follow SOLID design principles. Never write code that violates these principles. If you do, you will be asked to refactor it. Development Workflow Before making any changes, create and checkout a feature branch named feature-[brief-description] Write comprehensive tests for all new functionality Compile code and run all tests before committing Write detailed commit messages explaining the changes and rationale Commit all changes to the feature branch Architecture Overview Frontend : Next.js 14 with TypeScript and Tailwind CSS State Management : Zustand for client state, React Query for server state Backend : Node.js with Express and Prisma ORM Database : PostgreSQL Testing : Jest for unit tests, Playwright for E2E Code Standards Use TypeScript for all new code with strict type checking Follow the existing component structure in /src/components API routes follow RESTful conventions in /src/pages/api Use Prisma schema definitions for all database operations CSS classes should use Tailwind utilities; custom CSS only when necessary Quality Gates All code must compile without warnings Test coverage must remain above 80% All tests must pass before committing ESLint and Prettier must pass without errors File Organization Components: /src/components/[feature]/[ComponentName].tsx Pages: /src/pages/[route].tsx Utilities: /src/lib/[category]/[utility].ts Types: /src/types/[domain].ts","title":"Web Application Development Team"},{"location":"claude_web-application-development-team/#project-taskflow-web-application","text":"","title":"Project: TaskFlow Web Application"},{"location":"claude_web-application-development-team/#core-principles","text":"IMPORTANT : Whenever you write code, it MUST follow SOLID design principles. Never write code that violates these principles. If you do, you will be asked to refactor it.","title":"Core Principles"},{"location":"claude_web-application-development-team/#development-workflow","text":"Before making any changes, create and checkout a feature branch named feature-[brief-description] Write comprehensive tests for all new functionality Compile code and run all tests before committing Write detailed commit messages explaining the changes and rationale Commit all changes to the feature branch","title":"Development Workflow"},{"location":"claude_web-application-development-team/#architecture-overview","text":"Frontend : Next.js 14 with TypeScript and Tailwind CSS State Management : Zustand for client state, React Query for server state Backend : Node.js with Express and Prisma ORM Database : PostgreSQL Testing : Jest for unit tests, Playwright for E2E","title":"Architecture Overview"},{"location":"claude_web-application-development-team/#code-standards","text":"Use TypeScript for all new code with strict type checking Follow the existing component structure in /src/components API routes follow RESTful conventions in /src/pages/api Use Prisma schema definitions for all database operations CSS classes should use Tailwind utilities; custom CSS only when necessary","title":"Code Standards"},{"location":"claude_web-application-development-team/#quality-gates","text":"All code must compile without warnings Test coverage must remain above 80% All tests must pass before committing ESLint and Prettier must pass without errors","title":"Quality Gates"},{"location":"claude_web-application-development-team/#file-organization","text":"Components: /src/components/[feature]/[ComponentName].tsx Pages: /src/pages/[route].tsx Utilities: /src/lib/[category]/[utility].ts Types: /src/types/[domain].ts","title":"File Organization"}]}